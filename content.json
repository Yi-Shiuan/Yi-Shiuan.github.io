{"meta":{"title":"饅頭小舖","subtitle":"科技饅頭的開發筆記本","description":null,"author":"Yi-Shiuan","url":"http://yi-shiuan.github.io"},"pages":[{"title":"","date":"2018-01-03T03:26:48.914Z","updated":"2018-01-03T03:26:48.914Z","comments":false,"path":"links/index.html","permalink":"http://yi-shiuan.github.io/links/index.html","excerpt":"","text":""},{"title":"","date":"2018-01-03T03:26:48.914Z","updated":"2018-01-03T03:26:48.914Z","comments":false,"path":"tags/index.html","permalink":"http://yi-shiuan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[ProtoBuf] ProtoBuf Serialize 與 DeSerialize！","slug":"[ProtoBuf] ProtoBuf Serialize 與 DeSerialize！","date":"2016-10-07T14:44:15.000Z","updated":"2018-01-03T03:26:48.914Z","comments":true,"path":"2016/10/07/[ProtoBuf] ProtoBuf Serialize 與 DeSerialize！/","link":"","permalink":"http://yi-shiuan.github.io/2016/10/07/[ProtoBuf] ProtoBuf Serialize 與 DeSerialize！/","excerpt":"","text":"ProtoBuf這一篇應該是我ProtoBuf的系列文章第二篇，上一篇只簡單說了一些安裝方式與一些定義檔的設定根本就不知道該如何使用這一個好用的序列化工具。依樣會是使用protobuf-net這一個套件來做一個簡單的紀錄。 ProtoBuf 序列化在使用 ProtoBuf 的第一步就必須了解 Stream 的資料格式，因為在(反)序列化的過程中，預設都是使用 Stream 作為媒介。序列化的部份是使用 Serializer.Serialize這個方法來處理。 Simple Code 1 - 序列化123456789101112public void SerializeToStream&lt;T&gt;(T data, Stream stream)&#123; Serializer.Serialize(stream, data)&#125;public void Main()&#123; using (var stream = new MemoryStream()) &#123; this.SerializeToStream&lt;object&gt;(data, stream); &#125;&#125; 主要原因是若Stream關閉後就無法做任何的操作，所以交由外部來控制Stream的資源初始與回收。可以在序列化成為 Array 或 String 的格式。 Simple Code 2 - Serialize to byte array and string1234567891011121314151617181920212223public byte[] SerializeToBytes&lt;T&gt;(T data)&#123; byte[] result; using (var stream = new MemoryStream()) &#123; this.SerializeToStream(data, stream); result = stream.ToArray(); &#125; return result;&#125;public string SerializeToString&lt;T&gt;(T data)&#123; string result; using (var stream = new MemoryStream()) &#123; this.SerializeToStream(data, stream); result = Encoding.ASCII.GetString(stream.ToArray()); &#125; return result;&#125; 在Format 成 String 我是採用ASCII的編碼方式，讓他出來會像16進位的感覺。 也可以使用 Convert.ToBase64String(stream.ToArray()); 產生文字資料 ProtoBuf 反序列化在反序列化的部分也是預設採用 Stream 的資料格式來處理， Simple Code 3 - 反序列化1234public T SerializeToStream&lt;T&gt;(Stream stream)&#123; return Serializer.Deserialize&lt;T&gt;(stream, data)&#125; Simple Code 4 - 針對 Byte array and string deserialize12345678910111213141516public T DeSerializeFromBytes&lt;T&gt;(byte[] data)&#123; T result; using (var stream = new MemoryStream(data)) &#123; stream.Seek(0, SeekOrigin.Begin); result = this.DeSerializeFromStream&lt;T&gt;(stream); &#125; return result;&#125;public T DeSerializeFromString&lt;T&gt;(string data)&#123; return this.DeSerializeFromBytes&lt;T&gt;(Encoding.ASCII.GetBytes(data));&#125; 注： 若string是使用base64字元輸出，那麼在deserialize時就必須使用Convert.FromBase64String(data) 處理","categories":[{"name":"ProtoBuf","slug":"ProtoBuf","permalink":"http://yi-shiuan.github.io/categories/ProtoBuf/"}],"tags":[{"name":"ProtoBuf","slug":"ProtoBuf","permalink":"http://yi-shiuan.github.io/tags/ProtoBuf/"},{"name":"serialize","slug":"serialize","permalink":"http://yi-shiuan.github.io/tags/serialize/"},{"name":"deserialize","slug":"deserialize","permalink":"http://yi-shiuan.github.io/tags/deserialize/"}],"keywords":[{"name":"ProtoBuf","slug":"ProtoBuf","permalink":"http://yi-shiuan.github.io/categories/ProtoBuf/"}]},{"title":"[ProtoBuf] 初次見面","slug":"2016-10-06-protobuf初次見面","date":"2016-10-05T21:30:16.000Z","updated":"2018-01-03T03:26:48.914Z","comments":true,"path":"2016/10/05/2016-10-06-protobuf初次見面/","link":"","permalink":"http://yi-shiuan.github.io/2016/10/05/2016-10-06-protobuf初次見面/","excerpt":"","text":"ProtoBuf 初次見面什麼是ProtoBuf？這是一個Google所開發出的資料儲存結構或物件（反）序列的結構（如 JOSN、XML、msgpack等），在官方網站的介紹上有這麼一段： Protocol buffers are Google’s language-neutral,platform-neutral, extensible mechanism for serializing structured data– think XML, but smaller, faster, and simpler.You define how you want your data to be structured once,then you can use special generated source code to easily writeand read your structured data to and from a variety of data streams and using a variety of languages. from https://developers.google.com/protocol-buffers/ ProtoBuf支援各種主流的語言(ex: C#, C++, JAVA等)，在官方中的GitHub上有目前支援的語言實做，或是Third-party搜尋相關的實做套件。 ProtoBuf 優點 (反)序列速度快，方便於網路傳輸 產出格式內容小，方便存放至檔案或其他Service ProtoBuf 缺點 二進位格式，難以閱讀 使用上必須先作定義，需要先設定.proto檔案 在 C# 中使用 ProtoBuf在專案中我是使用third-party的套件，ProtoBuf-net套件可以在nuget上找到，會選擇這個套件主要是因為在使用上較為簡便，也支援較多的設定的方式來做資料，設定的方式稍後會有比較詳細一些的介紹。 ProtoBuf-net 定義方式ProtoBuf-net設定的方式支援了以下三種方式 Attribute這個方式，個人認為是一個較好的設定方式， 123456789101112131415161718[ProtoContract]public class TestClass&#123; [ProtoMember(1)] public int TestA &#123; get; set; &#125; [ProtoMember(2)] public string TestB &#123; get; set; &#125; [ProtoMember(3)] public TestClassB TestC &#123; get; set; &#125;&#125;[ProtoContract]public class TestClassB&#123; ...&#125; 這一個設定方式可以修改data model同時修改 Attribute 這樣在團隊使用上可以避免修改data model後也可馬上維護protobuf的設定，避免在runtime時因為設定上造成exception。 .proto檔案這一個方式是官方的標準設定，這個需要額外產生一份.proto檔案，定義方式與格式可參考官方網站的設定。 這一個方式因為多產生了一個.proto的檔案，在修改data model後，必須要再額外修改.proto的檔案，有時候在開發上會有不一致的情況；在使用上與設定上也相對較為複雜。 Runtime 定義這是在Application執行期間產生一份 RuntimeTypeModel，在Serializer的時候會以這一份RuntimeTypeModel為你的data model做序列化，以下提供語法參考設定方式 這一個方式會將原先定義覆蓋 1234var metaType = RuntimeTypeModel.Default.Add(typeof(TestClassA), true);metaType.AddSubType(100, typeof(TestA));RuntimeTypeModel.Default.Add(typeof(TestA), false); 這一個會複寫(或新增)原先的定義1234var metaType = RuntimeTypeModel.Default;var testA = metaType[typeof(TestClassA)];testA.AddSubType(100, typeof(TestA));metaType.Add(typeof(TestA), false); 總結目前會採用ProtoBuf序列化是因為先前使用JSON有效能上的問題與在存取Redis上產生較高的延遲，所以改採用ProtoBuf來作為資料序列化與存放到Redis的主要格式。雖然在閱讀上需要自己寫小工具做轉譯，但在一般情況擁有較好的效能展現。 其他更詳細的介紹可觀看protobuf-net 官方GitHub 參考資料Level up - protobuf-net - Serialize/DeSerialize data protobuf-net 官方GitHub Google protobuf","categories":[{"name":"ProtoBuf","slug":"ProtoBuf","permalink":"http://yi-shiuan.github.io/categories/ProtoBuf/"}],"tags":[{"name":"ProtoBuf","slug":"ProtoBuf","permalink":"http://yi-shiuan.github.io/tags/ProtoBuf/"},{"name":"serialize","slug":"serialize","permalink":"http://yi-shiuan.github.io/tags/serialize/"},{"name":"deserialize","slug":"deserialize","permalink":"http://yi-shiuan.github.io/tags/deserialize/"}],"keywords":[{"name":"ProtoBuf","slug":"ProtoBuf","permalink":"http://yi-shiuan.github.io/categories/ProtoBuf/"}]},{"title":"型態轉換的性能(long.parse vs ToString)","slug":"2016-08-04-型態轉換的性能(long.parse vs ToString)","date":"2016-08-04T07:31:09.000Z","updated":"2018-01-03T03:26:48.914Z","comments":true,"path":"2016/08/04/2016-08-04-型態轉換的性能(long.parse vs ToString)/","link":"","permalink":"http://yi-shiuan.github.io/2016/08/04/2016-08-04-型態轉換的性能(long.parse vs ToString)/","excerpt":"","text":"型態轉換的性能(long.parse vs ToString)寫在前面在工作上或是在系統開發上，時常會遇到轉型的問題，在小型系統上轉型對系統的負荷微乎其微，但是在巨大交易量的系統上面，就顯的重要了！在許多的1毫秒的累積會讓系統減少許多的交易，正好最近再處理系統的效能調教的問題，面臨到了這個問題順手筆記起來，以免再重新測試一次！另外，本篇文章針對long轉型ToString跟string轉型為long的比較，但相近的int, byte, decimal等等一樣可以適用喔！ 比較一：將long個位數的值轉換成為string測試的方式是宣告一個long型態的變數，執行100000次ToString的method所花費的時間約 8 ms ~ 12 ms ！ 123456789var longType = 1L;var sw = Stopwatch.StartNew();for(var i=0;i&lt;=100000;i++)&#123; longType.ToString();&#125; Console.WriteLine(sw.Elapsed);Console.WriteLine(sw.ElapsedMilliseconds); 將long個位數的值轉換成為string 比較二：將string轉換成為long這一次是宣告一個一字元的字串轉換成為long，並且執行100000次的long.Parse所需要的時間約 9 ms ~ 17 ms！在這兩次的比較差距並不多，但在實際使用的情況很少會用long存放1的資料，所以我們在測試使用1000000的數值，來做測試123456789var str = \"1\";var sw = Stopwatch.StartNew();for(var i=0;i&lt;=100000;i++)&#123; long.Parse(str);&#125; Console.WriteLine(sw.Elapsed);Console.WriteLine(sw.ElapsedMilliseconds); 將string轉換成為long 比較三：將1M轉換為字串這次使用一百萬的數值轉換成字串，所花費的時間為12 ms ~19 ms！ 123456789var varb = 1000000L;var sw = Stopwatch.StartNew();for (var i = 0; i &lt;= 100000; i++)&#123; varb.ToString();&#125;Console.WriteLine(sw.Elapsed);Console.WriteLine(sw.ElapsedMilliseconds); 將1M轉換為字串 比較四：將”1000000”轉換成為long這次使用一百萬的數值轉換成字串，所花費的時間為13 ms ~21 ms！ 123456789var varb = \"1000000\";var sw = Stopwatch.StartNew();for (var i = 0; i &lt;= 100000; i++)&#123; long.Parse(varb);&#125;Console.WriteLine(sw.Elapsed);Console.WriteLine(sw.ElapsedMilliseconds); 將1M轉換為字串 在時間上沒有相差很多，但long轉換成為string的效能仍然比較好！千萬不要小看這微小的差距，魔鬼永遠藏在細節中！另外轉換成long在所花費的時間也比較浮動。","categories":[{"name":"performance","slug":"performance","permalink":"http://yi-shiuan.github.io/categories/performance/"}],"tags":[{"name":"ToString","slug":"ToString","permalink":"http://yi-shiuan.github.io/tags/ToString/"},{"name":"long","slug":"long","permalink":"http://yi-shiuan.github.io/tags/long/"},{"name":"parse","slug":"parse","permalink":"http://yi-shiuan.github.io/tags/parse/"}],"keywords":[{"name":"performance","slug":"performance","permalink":"http://yi-shiuan.github.io/categories/performance/"}]},{"title":"【Redis】Redis Pub/Sub 製作應用程式間推播通知","slug":"2016-02-24-【Redis】Redis Pub Sub 製作應用程式間推播通知","date":"2016-02-23T19:55:09.000Z","updated":"2018-01-03T03:26:48.914Z","comments":true,"path":"2016/02/23/2016-02-24-【Redis】Redis Pub Sub 製作應用程式間推播通知/","link":"","permalink":"http://yi-shiuan.github.io/2016/02/23/2016-02-24-【Redis】Redis Pub Sub 製作應用程式間推播通知/","excerpt":"","text":"寫在前面在很多時候我們的部屬環境是很複雜的，無法使用單一個應用程式來解決我們的問題…（例如：Windows server與Linux Server、多個網站或多個不同類型執行個體、網站搭配console應用程式）此時當應用程式間需要配合時是一個很重要的議題，很多人會把資料存放到資料庫，應用程式在定期去擷取尚未處理的資料，等相關資料處理完畢後再到資料庫注記哪些記錄是已經處理完畢的，在這樣的軟體設計與環境相對簡單許多，但是在系統繁忙的時間中，這可不是一個樂觀的狀態了.. 現在Redis具有這樣的功能，可以協助我們設計應用程式間可以互相配合的一個機制，如此一來我們就不需要在透過定期存取資料庫，相關的訊息或相關的資料可以及時的處理！ Redis Command在使用推播前需要先瞭解三個指令，這三個指令是做應用程式推播時相關的指令 Publish官網的說明 Available since 2.0.0. Time complexity: O(N+M) where N is the number of clients subscribed to the receiving channel and M is the total number of subscribed patterns (by any client). Posts a message to the given channel. Redis最低版本：2.0這個指令主要的用途就是將訊息推進某一個頻道中。而時間複雜度是：O(N+M)，N是訂閱這個頻道的Client數量，M是所有訂閱者的數量。 Publish 指令的格式1Publish [channel] [message] Subscribe官網的說明 Available since 2.0.0. Time complexity: O(N) where N is the number of channels to subscribe to. Subscribes the client to the specified channels. Redis最低版本：2.0這個指令主要的用途是訂閱頻道，用來接收訂閱頻道中的訊息。而時間複雜度是：O(N)，N是指要訂閱頻道的總數目 Subscribe指令格式1SUBSCRIBE [channel 1] [channel 2] ... UnSubscribe官網的說明 Available since 2.0.0. Time complexity: O(N) where N is the number of clients already subscribed to a channel. Unsubscribes the client from the given channels, or from all of them if none is given. Redis最低版本：2.0這個指令主要的用途是取消訂閱頻道。而時間複雜度是：O(N)，N是指要取消訂閱頻道的總數目 UnSubscribe指令格式1UNSUBSCRIBE [channel 1] [channel 2] ... 系統開發存取Redis in C#：StackExchange.Redis這是一套存取Redis的一個套件，在稍候的程式開發中，都會使用到這個套件來存取Redis！ 1Install-Package StackExchange.Redis Subscribe開發Step1. 連結Redis在使用Redis需要先建立connection，才能連結到Redis。再使用StackExchange.Redis 套件時需要先引入他的namespace。 1using StackExchange.Redis; 設定Redis連線可以參考這篇文章上面會有參數的說明，這邊沒有一一列舉相關的參數設定。 123456789101112var configurationOptions = new ConfigurationOptions&#123; AbortOnConnectFail = false, Password = &quot;password&quot;, Ssl = false, ConnectTimeout = 6000, SyncTimeout = 6000&#125;;configurationOptions.EndPoints.Add(new DnsEndPoint(&quot;redis host&quot;, port));// IP:// configurationOptions.EndPoints.Add(IP Address, port));ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(configurationOptions); Step2. 訂閱頻道在StackExchange.Redis 取得連線後，開始開發訂閱頻道前要先取得Redis的Subcriber，才能發佈或是訂閱訊息 1var sub = redis.GetSubscriber(); 在訂閱訊息前，先看一下StackExchange.Redis中Subscribe的說明第一個參數是頻道名稱，這邊可以直接使用字串來代表RedisChannel的型別，第二個是一個Action的委派型別，第三個是commandFlag，這個主要的用途是在描述指令該如何執行，這個參數可以省略。 Subscribe的說明 這裡做一個範例，我在這裡訂閱了一個Study4TW的頻道，然後指定了收到這個訊息要做哪些事情（寫在Do Something中） 1234sub.Subscribe(&quot;Study4TW&quot;, (channel, message) =&gt; &#123; // Do Something &#125;); 如此只要寫在系統loading時就可以訂閱到該頻道，這個只要做一次就可以了，不需要每次執行！ Step3. 送出訊息！送出訊息的指令相當簡單，只要填上你是哪一個頻道，以及你要送出的訊息即可！在RedisChannel與RedisValue兩個型別都可以使用字串來傳遞即可。 Publish的說明 12var sub = redis.GetSubscriber();sub.Publish(\"Study4TW\", message); 在搭配前面Step2的程式碼，在這樣簡單的範例就可以在應用程序間互相通訊了！就不再需要透過資料庫來做訊息通知了，也不用使用IF去判別這一個訊息要怎麼處理或是交給哪一個method處理，增加程式碼的可讀性！是否受用無窮阿？ 參考資料Redis Pub/Sub Publish - Redis Subscribe - Redis UnSubscribe - Redis StackExchange.Redis GitHub StackExchange.Redis nuget","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yi-shiuan.github.io/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yi-shiuan.github.io/tags/Redis/"},{"name":"pub","slug":"pub","permalink":"http://yi-shiuan.github.io/tags/pub/"},{"name":"sub","slug":"sub","permalink":"http://yi-shiuan.github.io/tags/sub/"},{"name":"notify","slug":"notify","permalink":"http://yi-shiuan.github.io/tags/notify/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"http://yi-shiuan.github.io/categories/Redis/"}]}]}