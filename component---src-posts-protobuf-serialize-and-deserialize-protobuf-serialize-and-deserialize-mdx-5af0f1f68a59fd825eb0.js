(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{gsy3:function(e,t,r){"use strict";r.r(t),r.d(t,"_frontmatter",(function(){return i})),r.d(t,"default",(function(){return o}));var n=r("zLVn"),a=(r("q1tI"),r("7ljp")),i={title:"[ProtoBuf] ProtoBuf Serialize 與 DeSerialize！",description:"這一篇應該是我ProtoBuf的系列文章第二篇，上一篇只簡單說了一些安裝方式與一些定義檔 的設定根本就不知道該如何使用這一個好用的序列化工具。依樣會是使用protobuf-net 這一個套件來做一個簡單的紀錄。",tags:["ProtoBuf","serialize","deserialize"],categories:["ProtoBuf"],published:!0,comment:!0,date:"2016-10-07T22:44:15.000Z"},l={_frontmatter:i};function o(e){var t=e.components,r=Object(n.a)(e,["components"]);return Object(a.mdx)("wrapper",Object.assign({},l,r,{components:t,mdxType:"MDXLayout"}),Object(a.mdx)("h1",null,"ProtoBuf"),Object(a.mdx)("p",null,"這一篇應該是我ProtoBuf的系列文章第二篇，上一篇只簡單說了一些安裝方式與一些定義檔\n的設定根本就不知道該如何使用這一個好用的序列化工具。依樣會是使用protobuf-net\n這一個套件來做一個簡單的紀錄。"),Object(a.mdx)("h2",null,"ProtoBuf 序列化"),Object(a.mdx)("p",null,"在使用 ProtoBuf 的第一步就必須了解 Stream 的資料格式，因為在(反)序列化\n的過程中，預設都是使用 Stream 作為媒介。序列化的部份是使用 Serializer.Serialize\n這個方法來處理。"),Object(a.mdx)("h3",null,"Simple Code 1 - 序列化"),Object(a.mdx)("pre",null,Object(a.mdx)("code",{className:"language-cs",parentName:"pre"},"public void SerializeToStream<T>(T data, Stream stream)\n{\n    Serializer.Serialize(stream, data)\n}\n\npublic void Main()\n{\n    using (var stream = new MemoryStream())\n    {\n        this.SerializeToStream<object>(data, stream);\n    }\n}\n")),Object(a.mdx)("p",null,"主要原因是若Stream關閉後就無法做任何的操作，所以交由外部來控制Stream的資源初始與回收。\n可以在序列化成為 Array 或 String 的格式。"),Object(a.mdx)("h3",null,"Simple Code 2 - Serialize to byte array and string"),Object(a.mdx)("pre",null,Object(a.mdx)("code",{className:"language-cs",parentName:"pre"},"public byte[] SerializeToBytes<T>(T data)\n{\n    byte[] result;\n    using (var stream = new MemoryStream())\n    {\n        this.SerializeToStream(data, stream);\n        result = stream.ToArray();\n    }\n\n    return result;\n}\n\npublic string SerializeToString<T>(T data)\n{\n    string result;\n    using (var stream = new MemoryStream())\n    {\n        this.SerializeToStream(data, stream);\n        result = Encoding.ASCII.GetString(stream.ToArray());\n    }\n\n    return result;\n}\n")),Object(a.mdx)("p",null,"在Format 成 String 我是採用ASCII的編碼方式，讓他出來會像16進位的感覺。"),Object(a.mdx)("blockquote",null,Object(a.mdx)("p",{parentName:"blockquote"},"也可以使用 Convert.ToBase64String(stream.ToArray()); 產生文字資料")),Object(a.mdx)("h2",null,"ProtoBuf 反序列化"),Object(a.mdx)("p",null,"在反序列化的部分也是預設採用 Stream 的資料格式來處理，"),Object(a.mdx)("h3",null,"Simple Code 3 - 反序列化"),Object(a.mdx)("pre",null,Object(a.mdx)("code",{className:"language-cs",parentName:"pre"},"public T SerializeToStream<T>(Stream stream)\n{\n    return Serializer.Deserialize<T>(stream, data)\n}\n")),Object(a.mdx)("h3",null,"Simple Code 4 - 針對 Byte array and string deserialize"),Object(a.mdx)("pre",null,Object(a.mdx)("code",{className:"language-cs",parentName:"pre"},"public T DeSerializeFromBytes<T>(byte[] data)\n{\n    T result;\n    using (var stream = new MemoryStream(data))\n    {\n        stream.Seek(0, SeekOrigin.Begin);\n        result = this.DeSerializeFromStream<T>(stream);\n    }\n\n    return result;\n}\n\npublic T DeSerializeFromString<T>(string data)\n{\n    return this.DeSerializeFromBytes<T>(Encoding.ASCII.GetBytes(data));\n}\n")),Object(a.mdx)("blockquote",null,Object(a.mdx)("p",{parentName:"blockquote"},"注： 若string是使用base64字元輸出，那麼在deserialize時就必須使用\nConvert.FromBase64String(data) 處理")))}o.isMDXComponent=!0},zLVn:function(e,t,r){"use strict";function n(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}r.d(t,"a",(function(){return n}))}}]);
//# sourceMappingURL=component---src-posts-protobuf-serialize-and-deserialize-protobuf-serialize-and-deserialize-mdx-5af0f1f68a59fd825eb0.js.map