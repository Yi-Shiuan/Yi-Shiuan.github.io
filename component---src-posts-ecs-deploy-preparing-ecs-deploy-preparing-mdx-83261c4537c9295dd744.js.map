{"version":3,"sources":["webpack:///./src/posts/ecs-deploy-preparing/ecs-deploy-preparing.mdx","webpack:///./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"],"names":["_frontmatter","layoutProps","MDXContent","components","props","mdxType","isMDXComponent","_objectWithoutPropertiesLoose","source","excluded","key","i","target","sourceKeys","Object","keys","length","indexOf"],"mappings":"kOAKaA,EAAe,CAC1B,MAAS,+BACT,YAAe,6PACf,KAAQ,CAAC,MAAO,MAAO,KAAM,SAAU,eACvC,KAAQ,2BACR,WAAa,GAQTC,EAAc,CAClBD,gBAGa,SAASE,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,cALS,UAKT,iBAAeH,EAAiBG,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAC5E,wDACA,gCACA,uRAGA,iCACA,wKAEA,sGACA,gDACA,uDACA,yBAAK,qBAAU,CACX,UAAa,gBACb,WAAc,OAFb,ydA0BL,iDACA,yEACE,uBAAY,CACV,WAAc,KADhB,MADF,yBAKA,gCAEE,kBAAO,CACL,WAAc,cADhB,wBAKF,8DACA,yBAAK,qBAAU,CACX,UAAa,gBACb,WAAc,OAFb,oxBA4BL,4CACA,sFAEE,kBAAO,CACL,KAAQ,2GACR,WAAc,KAFhB,2BAIF,sGAEA,yBAAK,qBAAU,CACX,UAAa,gBACb,WAAc,OAFb,qSAUL,sDACA,oKAGA,kPAIA,4CAEE,kBAAO,CACL,KAAQ,2GACR,WAAc,KAFhB,kBAFF,6EASA,yBAAK,qBAAU,CACX,UAAa,gBACb,WAAc,OAFb,sLASL,gDACA,6LAGE,2BAAgB,CACd,WAAc,KADhB,mBAHF,4BAQA,yBAAK,qBAAU,CACX,UAAa,gBACb,WAAc,OAFb,0SAWL,6CACA,+HAEA,8DACA,6IAEA,yBAAK,qBAAU,CACX,UAAa,gBACb,WAAc,OAFb,0WAWL,uKAGA,0DACA,oGAEA,wHAEE,kBAAO,CACL,KAAQ,+FACR,WAAc,KAFhB,WAFF,UAOA,yBAAK,qBAAU,CACX,UAAa,gBACb,WAAc,OAFb,yOAUL,uIAEE,kBAAO,CACL,KAAQ,wBACR,WAAc,KAFhB,MAFF,sGAQA,yBAAK,qBAAU,CACX,UAAa,gBACb,WAAc,OAFb,4TASL,qEACA,2FACA,gCAEE,kBAAO,CACL,WAAc,cADhB,2DAIE,2BAAgB,CACd,WAAc,KADhB,YAJF,4EAWF,sGACA,yBAAK,qBAAU,CACX,UAAa,gBACb,WAAc,OAFb,uiCAwCL,2CACA,8DACA,wEACA,kGACA,uFACA,yBAAK,qBAAU,CACX,UAAa,gBACb,WAAc,OAFb,isBAkBL,qCACA,sDACA,sGACE,2BAAgB,CACd,WAAc,KADhB,YADF,QAKA,yBAAK,qBAAU,CACX,UAAa,gBACb,WAAc,OAFb,02BAuBL,qCACA,8CACE,2BAAgB,CACd,WAAc,KADhB,aAGF,qEACA,yBAAK,qBAAU,CACX,UAAa,gBACb,WAAc,OAFb,yRAcTH,EAAWI,gBAAiB,G,kCCrWb,SAASC,EAA8BC,EAAQC,GAC5D,GAAc,MAAVD,EAAgB,MAAO,GAC3B,IAEIE,EAAKC,EAFLC,EAAS,GACTC,EAAaC,OAAOC,KAAKP,GAG7B,IAAKG,EAAI,EAAGA,EAAIE,EAAWG,OAAQL,IACjCD,EAAMG,EAAWF,GACbF,EAASQ,QAAQP,IAAQ,IAC7BE,EAAOF,GAAOF,EAAOE,IAGvB,OAAOE,EAZT","file":"component---src-posts-ecs-deploy-preparing-ecs-deploy-preparing-mdx-83261c4537c9295dd744.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"AWS ECS Preparing Release 紀錄\",\n  \"description\": \"我們在aws 做Production deploy的時候，都會有一個pre production的環境，這個環境主要是為了在部署流程結束後可以做概念性驗證的環境 （主要測試：db connection是否正常、網路連線、裝機腳本等等）另一個方面可以預熱application，不過我們開始有越來越多採用docker的 application並且使用ECS的部署模式，但是ECS的Service建立後就無法修改Target Group，因此沒辦法如同EC2的部署模式只在最後切換Target Group\",\n  \"tags\": [\"ecs\", \"aws\", \"cd\", \"devops\", \"provisioned\"],\n  \"date\": \"2020-09-02T16:00:00.000Z\",\n  \"published\": true\n};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1>{`AWS ECS Preparing Release 紀錄`}</h1>\n    <h2>{`寫在前面`}</h2>\n    <p>{`我們在aws 做Production deploy的時候，都會有一個pre production的環境，這個環境主要是為了在部署流程結束後可以做概念性驗證的環境\n（主要測試：db connection是否正常、網路連線、裝機腳本等等）另一個方面可以預熱application，不過我們開始有越來越多採用docker的\napplication並且使用ECS的部署模式，但是ECS的Service建立後就無法修改Target Group，因此沒辦法如同EC2的部署模式只在最後切換Target Group`}</p>\n    <h2>{`構思&實作`}</h2>\n    <p>{`一開始其實想得很簡單，就是每次部署時都要產生新的 Target group 與新的ECS Service，\n將新產生的Target Group掛載到ELB的preparing規則上，然後驗證完畢後就把這組Target Group掛載到ELB的 public規則上就完成了一次的部署`}</p>\n    <p>{`但...事件總是沒想像中的美好，原先預計兩週內可以完成的項目變到了三週(其實中間也有對自己的要求增加ex: script可以重跑、自動移除舊版本等等)`}</p>\n    <h3>{`Deploy Configuration`}</h3>\n    <p>{`這個是為了減少使用者輸入資訊所做的一個設定，內容主要如下`}</p>\n    <pre><code {...{\n        \"className\": \"language-yaml\",\n        \"parentName\": \"pre\"\n      }}>{`VPC:\nRegion:\nHealthCheck:\n    Path: \"/\"\n    UnhealthyThreshold: 2\n    HealthyThreshold: 5\nLoadBalancer:\n    Preparing:\n    Public:\nAutoScaling:\n    Desired: 2\n    MaxCount: 10\n    MinCount: 2\nPolicies:\n    - Name: Scale-By-CPU-Usage\n      CoolDown: 150\n      Threshold: 75.0\n      Metric: ECSServiceAverageCPUUtilization\n    - Name: Scale-By-Memory-Usage\n      CoolDown: 150\n      Threshold: 75.0\n      Metric: ECSServiceAverageMemoryUtilization\n`}</code></pre>\n    <h3>{`Step1. 建立Target Group`}</h3>\n    <p>{`在建立Target Group其實沒什麼坑主要踩到的就是Target group的名字不能超過`}\n      <strong {...{\n        \"parentName\": \"p\"\n      }}>{`32`}</strong>\n      {`個字所以在命名規劃上需要思考一下該如何呈現`}</p>\n    <blockquote>\n\n      <p {...{\n        \"parentName\": \"blockquote\"\n      }}>{`我的命名規則是：環境-服務名稱-版本號`}</p>\n\n    </blockquote>\n    <p>{`這一步執行的結果需要將內容記錄下來，在修改ELB的rule時會需要用到`}</p>\n    <pre><code {...{\n        \"className\": \"language-yaml\",\n        \"parentName\": \"pre\"\n      }}>{`- name: Create Target Group\n  elb_target_group:\n    vpc_id: \"{{ VPC }}\"\n    region: \"{{ Region }}\"\n    state: present\n    name: \"{{ name }}\"\n    protocol: http\n    port: 80\n    health_check_protocol: http\n    health_check_interval: 30\n    health_check_timeout: 5\n    health_check_path: \"{{ HealthCheck.Path }}\"\n    unhealthy_threshold_count: \"{{ HealthCheck.UnhealthyThreshold }}\"\n    healthy_threshold_count: \"{{ HealthCheck.HealthyThreshold }}\"\n    successful_response_codes: \"200\"\n    target_type: instance\n    deregistration_delay_timeout: 60\n    tags:\n      Cluster: \"{{ cluster }}\"\n      ENV: \"{{ env }}\"\n      Version: \"{{ version }}\"\n      Name: \"{{ name }}\"\n      CreateTime: \"{{ lookup('pipe','date +%Y%m%d') }}\"\n  register: target_group_result\n`}</code></pre>\n    <h3>{`Step2. 連結ELB 的規則`}</h3>\n    <p>{`這一步在ansible中這定較為複雜所以改用了aws cli來處理，如果你想用純的ansible的方式處理，可以參考\n`}\n      <a {...{\n        \"href\": \"https://docs.ansible.com/ansible/latest/modules/elb_application_lb_module.html#elb-application-lb-module\",\n        \"parentName\": \"p\"\n      }}>{`這篇(elb_application_lb)`}</a></p>\n    <p>{`ansible的回傳都是陣列的形式所以在存取result的時候需要取得第一筆資料（如果你建立了多個target group\n就可以用loop來處理）`}</p>\n    <pre><code {...{\n        \"className\": \"language-yaml\",\n        \"parentName\": \"pre\"\n      }}>{`- name: Attach new target group to preparing load balancer rule\n  shell: |\n    aws elbv2 modify-rule \\\\\n      --actions Type=forward,TargetGroupArn={{ target_group_result.results[0].target_group_arn }} \\\\\n      --rule-arn {{ LoadBalancer.Preparing }} \\\\\n      --region {{ Region }}\n`}</code></pre>\n    <h3>{`Step3. 註冊新的Task Definition`}</h3>\n    <p>{`這一步驟來說應該是最複雜的一部分，我的Task Definition是由專案中的一個Configuration檔案設定\n在CI建置完成後上傳到artifact server，在執行部屬時用ansible下載到Deploy server上在讀取到\nansible的變數中。`}</p>\n    <p>{`在專案中的Configuration不是一整份的設定值，他只記錄了一部分的資訊(ex: cpu, memory, family等)\n主要的原因是有些資料需要在deploy時才能決定(ex: image version, env...)，\n所以我會在註冊task definition前先透過configuration建立一份完整的task definition，\n再透過aws cli來註冊新的task definition`}</p>\n    <p>{`這邊你會有個疑問，為何不直接採用\n`}\n      <a {...{\n        \"href\": \"https://docs.ansible.com/ansible/latest/modules/ecs_taskdefinition_module.html#ecs-taskdefinition-module\",\n        \"parentName\": \"p\"\n      }}>{`ansible module`}</a>\n      {`\n呢?主要原因是之前我們就有ecs deploy的CD流程，當時候有些參數我們需要但ansible無法支援\n所以轉用aws cli的方式進行。`}</p>\n    <pre><code {...{\n        \"className\": \"language-yaml\",\n        \"parentName\": \"pre\"\n      }}>{`- name: \"Register Task Definition\"\n  shell: |\n    aws ecs register-task-definition \\\\\n      --cli-input-json '{{ td_setting | to_json }}' \\\\\n      --region {{ Region }};\n`}</code></pre>\n    <h3>{`Step4. 新建ECS Service`}</h3>\n    <p>{`這一步我依舊採用aws cli來建立service，主要的原因是我的service通常會由兩個target group\n指向兩個不同的ELB與domain，在ansible官方網站上並沒有太多的說明與所需要的參數，因此我轉用了\naws cli，如同step3我會先將所需要的設定在一個ansible task上做好 產生了`}\n      <inlineCode {...{\n        \"parentName\": \"p\"\n      }}>{`service_setting`}</inlineCode>\n      {`的參數\n在執行cli時將參數轉換成JSON代入`}</p>\n    <pre><code {...{\n        \"className\": \"language-yaml\",\n        \"parentName\": \"pre\"\n      }}>{`- name: \"Create ECS service {{ service_setting.serviceName }}\"\n  shell: |\n    aws ecs create-service \\\\\n      --service-name '{{ service_setting.serviceName }}' \\\\\n      --cli-input-json '{{ service_setting | to_json }}' \\\\\n      --region {{ Region }};\n  register: ecs_service_create\n`}</code></pre>\n    <h2>{`切換Service Version`}</h2>\n    <p>{`切換服務版本這是一個比較大的工程，剛才的部署的複雜度更高一些，主要概念就是將新產生的target group\n掛載到真正線上服務的ELB上，不過呢這件事情衍生了許多細細小小的項目要處理的細節也比較多`}</p>\n    <h3>{`Step1. 確認Target group health count`}</h3>\n    <p>{`要切換前一定要先檢查Target group的target狀態，如果沒確認切換了一個還在做health check的target\ngroup就會發生線上可能當下沒有機器服務的窘境，所以第一步肯定就是確認health count`}</p>\n    <pre><code {...{\n        \"className\": \"language-yaml\",\n        \"parentName\": \"pre\"\n      }}>{`- name: Get Target Group Informantion\n  elb_target_group_info:\n    region: \"{{ Region }}\"\n    collect_targets_health: yes\n    names: \"{{ switch_target_group }}\"\n  register: target_group_result\n  failed_when: (target_group_result | json_query('target_groups[].targets_health_description[].target_health.state') | length) < {{ AutoScaling.Desired }}\n`}</code></pre>\n    <p>{`當如果target的health count沒有達到要求數量我就讓playbook失敗，之前在ec2的做法是要完全healthy\n才能夠往下運行但這樣會遇到當下要switch會無法switch，所以這次改變一下做法讓target的health count\n只要大於要求數量即可`}</p>\n    <h3>{`Step2. 取得public當前的target group`}</h3>\n    <p>{`為什麼要取得當前的target group？主要原因是怕瞬斷的情況發生，所以在切換的時候會有一個時間區間同時\n有兩個版本在運行最後再將舊版本移除`}</p>\n    <p>{`取得ELB中的rule資料ansible並沒有太好的方式處理，所以這道題還是只能靠aws cli來協助了，aws cli 只需要輸入public rule的arn就可以取得了\n詳細可以看`}\n      <a {...{\n        \"href\": \"https://awscli.amazonaws.com/v2/documentation/api/latest/reference/elbv2/describe-rules.html\",\n        \"parentName\": \"p\"\n      }}>{`aws cli`}</a>\n      {` 的官方文件`}</p>\n    <pre><code {...{\n        \"className\": \"language-yaml\",\n        \"parentName\": \"pre\"\n      }}>{`- name: \"Get load balancer rule for {{ service_name | upper }}\"\n  shell: |\n    aws elbv2 describe-rules \\\\\n      --rule-arns {{ LoadBalancer.Public | join(' ') }} \\\\\n      --region {{ Region }}\n  register: current_rules\n`}</code></pre>\n    <p>{`接下來這個就需要比較耐心地來處理了，因為ansible shell的回傳result會有個stdout屬性，這就是aws cli最後回傳的資料，所以我們要解析這個\n資訊，然後ansible 的json_query是用`}\n      <a {...{\n        \"href\": \"https://jmespath.org/\",\n        \"parentName\": \"p\"\n      }}>{`這個`}</a>\n      {`來實作的，所以我們可以透過這個先取得我們想要的結果，當然他會有一個target group arn資料\n不過我們後面需要一些壓在target group tag上的資料，所以我在這邊把他先取回來`}</p>\n    <pre><code {...{\n        \"className\": \"language-yaml\",\n        \"parentName\": \"pre\"\n      }}>{`- name: Get target group informantion of current load balance setting\n  elb_target_group_info:\n    region: \"{{ Region }}\"\n    target_group_arns: \"{{ current_rules.stdout | from_json | json_query('Rules[].Actions[].ForwardConfig.TargetGroups[].TargetGroupArn') }}\"\n  register: current_target_group_result\n`}</code></pre>\n    <h3>{`Step3. 把Prepare的target group跟public的整合在一起`}</h3>\n    <p>{`在ansible還時沒有一個簡單的設定，去修改ELB rule的target group連結，所以還是得透過aws cli來作了`}</p>\n    <blockquote>\n\n      <p {...{\n        \"parentName\": \"blockquote\"\n      }}>{`下面的ansible tasks我將它設定成一個role，主要原因是我有兩個target group在處理，\n`}\n        <inlineCode {...{\n          \"parentName\": \"p\"\n        }}>{`set_fact`}</inlineCode>\n        {`去跑loop的情況會比較複雜所以我設計成一個role，在playbook上採用loop\n來執行這個role，如此一來邏輯比較清晰也比較好維護`}</p>\n\n    </blockquote>\n    <p>{`如此一來在public 的規則上就有兩個target group的容器在服務了，這樣的情況我會讓他維持約1分鐘，再將原先的target group移除`}</p>\n    <pre><code {...{\n        \"className\": \"language-yaml\",\n        \"parentName\": \"pre\"\n      }}>{`- name: Generate load balance rule setting\n set_fact:\n   target_rule_setting: |\n     [\n       {\n         \"Type\": \"forward\",\n         \"ForwardConfig\": {\n           \"TargetGroups\": [\n             {\n               \"TargetGroupArn\": '{{ target_group[0].arn }}',\n               \"Weight\": {{ target_group[0].weight }}\n             },\n             {\n               \"TargetGroupArn\": '{{ target_group[1].arn }}',\n               \"Weight\": {{ target_group[1].weight }}\n             }\n           ],\n           \"TargetGroupStickinessConfig\": {\n             \"Enabled\": false\n           }\n         }\n       }\n     ]\n- name: \"Attach to public rule\"\n shell: |\n   aws elbv2 modify-rule \\\\\n     --actions '{{ target_rule_setting | to_json }}' \\\\\n     --rule-arn {{ target_rule }} \\\\\n     --region {{ Region }}\n\n- name: \"Remove old version\"\n shell: |\n   aws elbv2 modify-rule \\\\\n     --actions Type=forward,TargetGroupArn={{ item }} \\\\\n     --rule-arn {{ LoadBalancer.Release[ansible_loop.index0].Rule }} \\\\\n     --region {{ Region }}\n`}</code></pre>\n    <h3>{`Step4. 處置舊版本的服務`}</h3>\n    <p>{`移轉成功後需要把舊版本的service關機或是移除，我的選擇是暫時關閉`}</p>\n    <p>{`關閉服務聽起來很簡單，但我用aws cli執行將需求值改成0，但....一點效果都沒有！！`}</p>\n    <p>{`還記得一開始設定的autoscaling嗎....沒錯就是他！當你把desired改成0，會跟autoscaling設定的發生衝突所以變得無效`}</p>\n    <p>{`在調整desired改成0前，要把autoscaling設定移除才能順利的關閉service將cluster的資源釋出！`}</p>\n    <pre><code {...{\n        \"className\": \"language-yaml\",\n        \"parentName\": \"pre\"\n      }}>{`- name: Shutdown ECS service\n  shell: |\n    aws application-autoscaling register-scalable-target \\\\\n      --service-namespace ecs \\\\\n      --scalable-dimension ecs:service:DesiredCount \\\\\n      --resource-id service/{{ current_target_group_result.target_groups[0].tags[\"Cluster\"] }}/{{ current_target_group_result.target_groups[0].tags[\"Name\"] }} \\\\\n      --min-capacity 0 \\\\\n      --max-capacity 0 \\\\\n      --region {{ Region }};\n    aws ecs update-service \\\\\n      --cluster {{ current_target_group_result.target_groups[0].tags[\"Cluster\"] }} \\\\\n      --service {{ current_target_group_result.target_groups[0].tags[\"Name\"] }} \\\\\n      --desired-count 0 \\\\\n      --region {{ Region }};\n`}</code></pre>\n    <h3>{`Step5. 移除`}</h3>\n    <p>{`這是整個部署流程的尾聲了（或是你可以選擇不做....）`}</p>\n    <p>{`我的做法是先將整個ecs cluster的service列出來，然後取得target group資料，再由target group資料取得tag是否含有`}\n      <inlineCode {...{\n        \"parentName\": \"p\"\n      }}>{`obsolete`}</inlineCode>\n      {`的tag`}</p>\n    <pre><code {...{\n        \"className\": \"language-yaml\",\n        \"parentName\": \"pre\"\n      }}>{`- name: Get obsolete target group info\n  elb_target_group_info:\n    region: \"{{ Region }}\"\n    target_group_arns: \"{{ target_group_arn | json_query('loadBalancers[].targetGroupArn') }}\"\n  register: ecs_tg_result\n\n- name: Delete obsolete ECS service and target group\n  shell: |\n    aws ecs delete-service \\\\\n      --cluster {{ ecs_tg_result.target_groups[0].tags['Cluster'] }} \\\\\n      --service {{ ecs_tg_result.target_groups[0].tags['Service'] }} \\\\\n      --region {{ Region }} ;\n    aws elbv2 delete-target-group \\\\\n      --target-group-arn {{ ecs_tg_result.target_groups[0].target_group_arn }} \\\\\n      --region {{ Region }} ;\n    aws elbv2 delete-target-group \\\\\n      --target-group-arn {{ ecs_tg_result.target_groups[1].target_group_arn }} \\\\\n      --region {{ Region }} ;\n  when: ecs_tg_result.target_groups[0].tags['Obsolete'] is defined\n`}</code></pre>\n    <h3>{`Step6. 標記`}</h3>\n    <p>{`部署的最後一步，標記已經被關閉的服務變成`}\n      <inlineCode {...{\n        \"parentName\": \"p\"\n      }}>{`obsolete`}</inlineCode></p>\n    <p>{`這是為了下次部署可以把這些服務刪除，如果前一個步驟不做的話，這個步驟也是可以省略的。`}</p>\n    <pre><code {...{\n        \"className\": \"language-yaml\",\n        \"parentName\": \"pre\"\n      }}>{`- name: Configure obsolete target group\n shell: |\n   aws elbv2 add-tags \\\\\n     --resource-arns {{ item.target_group_arn }} \\\\\n     --tags '[{\"Key\": \"Obsolete\", \"Value\": \"yes\"}]' \\\\\n     --region {{ Region }}\n loop: \"{{ current_target_group_result.target_groups }}\"\n`}</code></pre>\n  </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}"],"sourceRoot":""}