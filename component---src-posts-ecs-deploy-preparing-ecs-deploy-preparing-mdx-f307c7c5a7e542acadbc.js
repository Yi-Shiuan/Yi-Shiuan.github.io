(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{"Bw+d":function(n,e,t){"use strict";t.r(e),t.d(e,"_frontmatter",(function(){return c})),t.d(e,"default",(function(){return u}));var r=t("zLVn"),o=(t("q1tI"),t("7ljp")),c={title:"AWS ECS Pre Production",description:"我們在aws 做Production deploy的時候，都會有一個pre production的環境，這個環境主要是為了在部署流程結束後可以做概念性驗證的環境 （主要測試：db connection是否正常、網路連線、裝機腳本等等）另一個方面可以預熱application，不過我們開始有越來越多採用docker的 application並且使用ECS的部署模式，但是ECS的Service建立後就無法修改Target Group，因此沒辦法如同EC2的部署模式只在最後切換Target Group",tags:["ecs","aws","cd","devops"],date:"2020-08-13T16:00:00.000Z",published:!1},a={_frontmatter:c};function u(n){var e=n.components,t=Object(r.a)(n,["components"]);return Object(o.mdx)("wrapper",Object.assign({},a,t,{components:e,mdxType:"MDXLayout"}),Object(o.mdx)("h1",null,"AWS ECS Pre Production"),Object(o.mdx)("h2",null,"寫在前面"),Object(o.mdx)("p",null,"我們在aws 做Production deploy的時候，都會有一個pre production的環境，這個環境主要是為了在部署流程結束後可以做概念性驗證的環境\n（主要測試：db connection是否正常、網路連線、裝機腳本等等）另一個方面可以預熱application，不過我們開始有越來越多採用docker的\napplication並且使用ECS的部署模式，但是ECS的Service建立後就無法修改Target Group，因此沒辦法如同EC2的部署模式只在最後切換Target Group"),Object(o.mdx)("h2",null,"想法與流程"),Object(o.mdx)("h3",null,"想法"),Object(o.mdx)("p",null,"在每次部署時都要產生新的Target Group與新的ECS Service，將新產生的Target Group掛載到Preparing的Load balancer rule上，確認過後再將新產生的Target Group\n掛載到正式服務的Load balancer rule，最後再將原先的Target Group 移出Load balancer rule"))}u.isMDXComponent=!0},zLVn:function(n,e,t){"use strict";function r(n,e){if(null==n)return{};var t,r,o={},c=Object.keys(n);for(r=0;r<c.length;r++)t=c[r],e.indexOf(t)>=0||(o[t]=n[t]);return o}t.d(e,"a",(function(){return r}))}}]);
//# sourceMappingURL=component---src-posts-ecs-deploy-preparing-ecs-deploy-preparing-mdx-f307c7c5a7e542acadbc.js.map