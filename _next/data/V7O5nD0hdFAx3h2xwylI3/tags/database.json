{"pageProps":{"posts":[{"id":1664841600,"fileName":"postgresql-insert-or-update","url":"2022/10/04/postgresql-insert-or-update","title":"Postgresql 的Merge語法","description":"在SQL Server中有一個語法是merge的語法，他可以根據特定的條件執行特定的操作，如資料存在就更新不存在就新增。 但在Postgresql中，似乎沒有merge的語法可以使用...但在程式理先去得資料在判斷是否更新或新增這樣的情境容易導致一些後遺症.... 在google後，其實有很多方式但...嘗試後只有這個方法是可行的，所以在這邊筆記一下","date":"2022-10-04T00:00:00.000Z","tags":["postgresql","database"],"published":true,"content":"\n在SQL Server中有一個語法是`merge`的語法，他可以根據特定的條件執行特定的操作，如資料存在就更新不存在就新增。\n但在Postgresql中，似乎沒有merge的語法可以使用...但在程式理先去得資料在判斷是否更新或新增這樣的情境容易導致一些後遺症....\n在google後，其實有很多方式但...嘗試後只有這個方法是可行的，所以在這邊筆記一下\n\n> postgresql的版本是13\n\n```plsql\nINSERT INTO public.table (user_id, name, email)\nVALUES (@userid, @username, @user_email)\nON CONFLICT (user_id)\n    DO UPDATE SET (name, email) = (@username, @user_email)\nWHERE members.user_id = @userid;\n```\n當table中user_id衝突時，就會自動執行update，這樣一來根SQL server中的merge語句就相同了！\n\n\n### 參考資料\n\n[postgresql insert](https://www.postgresql.org/docs/current/sql-insert.html)\n"},{"id":1664496000,"fileName":"postgresql-dapper-json-deserialize","url":"2022/09/30/postgresql-dapper-json-deserialize","title":"透過Dapper存取Postgresql Json column 自動反序列化","description":"有時候一個物件我會把它序列化後使用JSON的方式存放到postgresql中，但把它取出後卻無法透過ORM直接做資料的對應，然後自己就土炮了做法， 把資料撈出後在針對欄位去反序列化，這樣做一開始覺得好像沒什麼，但這樣的資料變多了以後發現問體頗大，所以上網找了一些解決方案， 但關鍵字嚇得不好反而找到許多更奇怪的做法後來在stackoverflow上看到了這招真心覺得很棒的方法，於是筆記下來！","tags":["database",".net"],"date":"2022-09-30T00:00:00.000Z","published":true,"content":"\n有時候一個物件我會把它序列化後使用JSON的方式存放到postgresql中，但把它取出後卻無法透過ORM直接做資料的對應，然後自己就土炮了做法，\n把資料撈出後在針對欄位去反序列化，這樣做一開始覺得好像沒什麼，但這樣的資料變多了以後發現問體頗大，所以上網找了一些解決方案，\n但關鍵字嚇得不好反而找到許多更奇怪的做法後來在stackoverflow上看到了這招真心覺得很棒的方法，於是筆記下來！\n\n當初也有嘗試過使用`CustomPropertyTypeMap`來處理，但這個對於欄位與Class屬性名稱對應不同時使用，\n當欄位資料需要做特殊的轉換時就需要Dapper的ITypeHandler來定義什麼樣的資料型別需要怎麼去做處理，\n所以建立了一個class去繼承 `SqlMapper.ITypeHandler`然後實作類似Get/Set的物件存取的方式。\n\n```cs\npublic class JsonTypeHandler : SqlMapper.ITypeHandler\n{\n    public void SetValue(IDbDataParameter parameter, object value)\n    {\n        parameter.Value = JsonSerializer.Serialize(value);\n    }\n\n    public object Parse(Type destinationType, object value)\n    {\n        return value == null ? destinationType : JsonSerializer.Deserialize(value.ToString()!, destinationType);\n    }\n}\n```\n\n做好了這樣的物件後，只要在資料庫的連線物件上註冊`當遇到xxxx`型別時，使用JsonTypeHandler做處理，這樣一來就必須要土炮把資料撈出來後\n使用callback的方式做反序列化在僵值放回原本需要的物件中，減少了許多複雜的狀態。\n\n```cs\npublic class DbContext\n{\n    private string connectionString;\n    private readonly ILogger<DbContext> logger;\n\n    public DbContext(IServiceProvider provider)\n    {\n        略...\n\n        // 先決定目標的型別，再來把相對應的處理方式填上就行了\n        SqlMapper.AddTypeHandler(typeof(Dictionary<string, string>), new JsonTypeHandler());\n    }\n\n    /// 略...\n}\n```\n\n## 參考資料\n\n[can-dapper-deserialize-json-stored-as-text](https://stackoverflow.com/questions/49888334/can-dapper-deserialize-json-stored-as-text)\n"}],"tags":{"postgresql":1,"database":2,".net":1,"aws":4,"devops":7,"prevision":6,"iot":2,"platformio":2,"arduino":2,"esp":1,"elk":3,"azure":4,"vulnerability":1,"ssl":2,"vmss":1,"cd":3,"study4":1,"dotnetconf":1,"selenium":2,"tdd":1,"react":3,"jest":1,"next.js":1,"frontend":1,"layout":1,"ec2":1,"iac":1,"terraform":1,"ci":1,"jenkins":1,"ecs":1,"ansible":1,"redis":2,"protobuf":2,"serialize":2,"deserialize":2,"pub":1,"sub":1,"notify":1}},"__N_SSG":true}