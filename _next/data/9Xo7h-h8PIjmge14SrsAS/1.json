{"pageProps":{"current":1,"posts":[{"id":1671494400,"fileName":"dotnetconf-2022@study4","url":"2022/12/20/dotnetconf-2022@study4","title":"邁向元宇宙部署模式","description":"dotnetconf 2022 ＠ study4 邁向元宇宙部署模式","tags":["devops","study4","dotnetconf"],"date":"2022-12-20T00:00:00.000Z","published":true,"content":"\n在dotent conf 2022中分享的投影片內容\n\n[投影片下載](https://cdn.adhome.com.tw/blogger/dotnet-conf-2022@study4/dotent-conf-2022@study4.pdf)\n\n[從黑暗時代到現代化的雲端部署與維運](https://brunojan.net/posts/2021/12/20/dotnetconf-2021@study4)\n\n元宇宙是一個陌生的名詞，今天我用它來當作下一個世代的部署方式\n這個世代部署，我們要盡可能地減少config的設定或者是零Config，要達成這樣的狀態首先需要有各式的infra來支援，不然很難達成這樣的操作模式。\n\n當你的config越變越少，你的程式碼不再需要環境設定，那你在DevOps又更近了一步！\n"},{"id":1670630400,"fileName":"aws-dynamic-site-canary-deployment","url":"2022/12/10/aws-dynamic-site-canary-deployment","title":"非靜態網站使用AWS做金絲雀部署","description":"在佔新作改版時，我們會希望可以先讓一部分使用者先做測試而不是將使用者一次更新。在AWS透過ELB接收網路流量到後面的Container的流量設定該怎麼做呢？ 另外我們還希望可以做到如同AWS的新舊版本可以讓使用者自由的切換，這個該又如何處理這樣的需求呢？","date":"2022-12-10T00:00:00.000Z","tags":["aws","frontend","next.js"],"published":true,"content":"\n在佔新作改版時，我們會希望可以先讓一部分使用者先做測試而不是將使用者一次更新。在AWS透過ELB接收網路流量到後面的Container的流量設定該怎麼做呢？\n另外我們還希望可以做到如同AWS的新舊版本可以讓使用者自由的切換，這個該又如何處理這樣的需求呢？\n\n## 什麼是金絲雀部署？\n\n金絲雀部署的劉來是在礦工下礦坑時會先讓金絲雀飛進礦坑中，倘若金絲雀沒有了叫聲，表示礦坑底下的瓦斯濃度或是其他氣體濃度太高，礦工下礦坑就會有生命危險。\n金絲雀部署也有其他名稱如：礦工部署與灰度部署\n\n## 系統架構配置\n\n當使用者進入系統時，有90%的流量進入了`Old Version`中另外有10%的流量進入`New Version`中\n\n![AWS system architecture](aws-dynamic-site-canary-deployment/system-architecture.png)\n\n## Load balancer的設定\n\n在ELB中的設定呢分成兩個區塊，首先在主要的Rule設定上的`Forward to`中設定兩個target group，權重設定分配比例按照9:1的設定，Group-level stickiness要設定多久後要將重新做分配，就可以自動的建立金絲雀部署了\n\n![第一個TG設定](aws-dynamic-site-canary-deployment/main-tg-setting.png)\n\n但想要想可以自求的切換版本那只單純設定一條rule是不夠的！原因是因為Next.js的靜態檔案ex: js, css 靜態檔案的路徑是`_next/static/{BUILD_ID}`，所以要針對這樣的路徑多設定兩個不同的rule來做指向\n所以ELB的設定要多一個Path的條件，match了build id 才能導向該Container，這樣每次部署只要更新相對應的路徑就可以了！\n\n還需要再多一個設定，那就是切換舊版後需要一個條件讓使用者可以導向舊版的網站，所以這邊可以使用Query string或是Header的值來做判斷導向哪一個Target group中\n\n> 以前實作時，Next.js產生靜態檔案的路徑是`_next/{BUILD_ID}`\n"},{"id":1670198400,"fileName":"nextjs-i18n-with-react-intl","url":"2022/12/05/nextjs-i18n-with-react-intl","title":"Next.JS 靜態網站 + React-Intl 的 i18n","description":"多國語系在許多網站已經是不可或缺的一個功能，在自己的研究中想做這事件情很久了，在公司的日常開發中也有許多這樣的功能，但前人已經設定好了，沒有從頭來過的感覺 剛好這兩天終於有一個契機與必要實作的需求出現了。於是就把自己實作的步驟記錄下來！","date":"2022-12-05T00:00:00.000Z","tags":["react","next.js","i18n"],"published":true,"content":"\n多國語系在許多網站已經是不可或缺的一個功能，在自己的研究中想做這事件情很久了，在公司的日常開發中也有許多這樣的功能，但前人已經設定好了，沒有從頭來過的感覺\n剛好這兩天終於有一個契機與必要實作的需求出現了。於是就把自己實作的步驟記錄下來！\n\n### 1. 安裝React-intl\n\n```bash\nyarn add react-intl\n```\n\n### 2. 設定next.config.js\n\n開啟next.config.js設定預設的語系以及支援的語系設定，locales是設定支援的語系檔案而 defaultLocale 當沒有傳入語系設定時所使用的預設語系\n\n```js\nmodule.exports = {\n  ...\n  i18n: {\n    locales: ['en', 'tw'],\n    defaultLocale: 'tw',\n  },\n  ...\n};\n```\n\n### 3. 放置語系包的位置\n\n在語系設定上我的檔案會放在`/src/locales`中，裡面的檔案要對應到在**next.config.js**中所設定的語系相同，網站中有需要用到多國語系的語系檔案都可以在這邊設定\n\n語系的檔案結構\n```txt\n.\n├── ...\n├── src\n│   ├── locales\n│   │   ├── en.ts\n│   │   ├── tw.ts\n│   │   └── index.ts\n│   ├── pages\n│   │   ├── _app.ts\n│   └── ...\n└── ...\n```\n語系資料對應後續我們就可以使用`FormattedMessage`的Component來取得該資料值。\n```typescript\n// en.ts檔案設定\nexport const en = {\n    my_title: `Bruno's Jan Tech blogger`\n}\n\n// tw.ts\nexport const tw = {\n    my_title: `Bruno's 技術筆記`\n}\n\n// index.ts\nimport { en } from \"./en\";\nimport { tw } from \"./tw\";\n\nexport const messages: any = {\n    tw,\n    en\n}\n```\n\n### 4. 設定_app.tsx檔案\n\n在_app.tsx中設定`IntlProvider`以及語系包的資料設定\n\n```tsx\nimport { AppProps } from 'next/app';\nimport { useRouter } from 'next/router';\nimport React, { ReactElement } from 'react';\nimport { IntlProvider } from 'react-intl';\nimport { messages } from '~/locales';\n\nconst App: any = ({\n                      Component,\n                      pageProps,\n                  }: AppProps) => {\n    const router = useRouter();\n    const {\n        locale,\n        defaultLocale,\n    } = router;\n    const message: any = messages[locale];\n    return <IntlProvider locale={ locale } defaultLocale={ 'tw' } messages={ message }>\n        <Component { ...pageProps } />\n    </IntlProvider>;\n};\n\nexport default App;\n```\n\n接下來就可以在畫面上需要多語言翻譯的位置加上下列程式碼就可以展現多國語系了！\n```tsx\nimport { FormattedMessage } from 'react-intl';\n\n\n<FormattedMessage id='my_title' defaultMessage='My default title' />\n```\n\n### 輸出靜態網站\n\n完成了多語系社的設定以後，當要輸出靜態網站時出現了錯誤...竟然說i18n不支援`next export`！\n\n```bash\n$ next export\ninfo  - using build directory: /Users/Yi-Shiuan/Documents/git/Blogger/.next\ninfo  - Copying \"static build\" directory\ninfo  - No \"exportPathMap\" found in \"/Users/Yi-Shiuan/Documents/git/Blogger/next.config.js\". Generating map from \"./pages\"\nError: i18n support is not compatible with next export. See here for more info on deploying: https://nextjs.org/docs/deployment\n    at /Users/Yi-Shiuan/Documents/git/Blogger/node_modules/next/dist/export/index.js:147:19\n    at async Span.traceAsyncFn (/Users/Yi-Shiuan/Documents/git/Blogger/node_modules/next/dist/trace/trace.js:79:20)\nerror Command failed with exit code 1.\ninfo Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\nerror Command failed with exit code 1.\ninfo Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\n```\n\n後來在官網中找到了這一段文字..\n\n> Note that Internationalized Routing does not integrate with next export as next export does not leverage the Next.js routing layer.\n> Hybrid Next.js applications that do not use next export are fully supported.\n>\n> [Next.js - Internationalized Routing](https://nextjs.org/docs/advanced-features/i18n-routing#limits-for-the-i18n-config)\n\n好吧，看起來我想輸出靜態網站不支援這樣的設定，所以只好動點手腳讓系統支援他！\n\n用靜態路由的設定來讓他可以支援多國語系\n\n```tsx\nexport const getStaticPaths: GetStaticPaths = async (): Promise<any> => {\n    return {\n        paths: [\n            { params: { lang: 'tw' } },\n            { params: { lang: 'en' } },\n        ],\n        fallback: false,\n    };\n};\n```\n再次修改_app.tsx\n\n使用路由取得語系，再去設定 `IntlProvider`載入的語系設定\n```tsx\nimport { AppProps } from 'next/app';\nimport { useRouter } from 'next/router';\nimport React, { ReactElement } from 'react';\nimport { IntlProvider } from 'react-intl';\nimport { messages } from '~/locales';\n\nconst App: any = ({\n                      Component,\n                      pageProps,\n                  }: AppProps) => {\n    library.add(fas, fab);\n    const router = useRouter();\n    const {\n        locale,\n        defaultLocale,\n    } = router;\n    const { lang } = router.query;\n    // @ts-ignore\n    const message: any = messages[lang ?? 'tw'];\n\n    return <IntlProvider locale={ locale ?? 'tw' } defaultLocale={ 'tw' } messages={ message }>\n        <Component { ...pageProps } />\n    </IntlProvider>;\n};\n\nexport default App;\n```\n\n最後移除next.config.js中的設定\n```js\n    i18n: {\n        locales: ['en', 'tw'],\n        defaultLocale: 'tw',\n    },\n```\n\n這樣就可以在靜態網站中擁有多國語系囉！\n\n### 參考資料\n\n[Next.js - Internationalized Routing](https://nextjs.org/docs/advanced-features/i18n-routing#limits-for-the-i18n-config)\n\n[Internationalizing Next.js app with react-intl by Iskren Lalov](https://www.laloov.com/posts/internationalizing-next-js-app-with-react-intl)\n"},{"id":1666224000,"fileName":"gatsbyjs-to-nextjs","url":"2022/10/20/gatsbyjs-to-nextjs","title":"從Gatsby.js轉換到Next.js","description":"紀錄從Gatsby.js轉換到了Next.js的踩地雷過程","date":"2022-10-20T00:00:00.000Z","tags":["react","gatsby.js","next.js"],"published":true,"content":"\n其實Gatsby.js並沒有什麼不好，只是他每一次改版都需要花費許多精力去做更新，我從1.0用到了3.0，最後4.0真的讓我痛下決心轉換到了Next.js的懷抱\n\n雖然官方有介紹如何從Gatsby.js遷移到Next.js的範例，但說真的還有許多沒有寫清楚的地方這邊先做幾個紀錄\n\n## 更新package.json\n\n除離移除所有的Gatsby.js的套件外，還需要安裝幾個套件這幾個套件官方都有說明主要是為了渲染markdown的文件以及讀取markdown的文件的套件功能\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"next build\",\n    \"export\": \"next export\",\n    \"dev\": \"next dev\",\n    \"start\": \"next start\"\n  },\n  \"subpath\": \"`/*\",\n  \"dependencies\": {\n    \"gray-matter\": \"^4.0.3\",\n    \"next\": \"^12.3.1\",\n    \"react-markdown\": \"^8.0.3\",\n    \"react-syntax-highlighter\": \"^15.4.4\",\n    \"remark\": \"^14.0.2\",\n    \"remark-html\": \"^15.0.1\"\n  }\n}\n```\n\n## 讀取markdown檔案\n\n在部落格中的markdown文件資料夾是這樣放的 `src/posts/{post}.mdx`\n\n```typescript\n// posts.ts\n\nimport dayjs from 'dayjs';\nimport fs from 'fs';\nimport matter from 'gray-matter';\nimport { join } from 'path';\n\nexport type Post = {\n    id: number;\n    fileName: string;\n    url: string;\n    title: string;\n    tags: string[];\n    content: string;\n    date: Date;\n    publish: boolean;\n    description: string;\n}\n\nconst postsDirectory = join(process.cwd(), '<<markdown 檔案位置>>');\nlet posts: Post[] = [];\n\n// 取得markdown文件中的內容\nexport const getPost: Function = (slug: string): Post => {\n    const realSlug = slug.replace(/\\.mdx$/, '');\n    const fullPath = join(postsDirectory, `${ slug }`);\n    const fileContents = fs.readFileSync(fullPath, 'utf8');\n    const {\n        data,\n        content,\n    } = matter(fileContents);\n\n    const obj = JSON.parse(JSON.stringify(data));\n    return {\n        id: dayjs(data.date).unix(),\n        fileName: realSlug,\n        url: `${ dayjs(data.date).format('YYYY/MM/DD') }/${ realSlug }`,\n        ...obj,\n        content,\n    } as Post;\n};\n\n// 列表目標資料夾中的所有markdown檔案，並且逐一取得markdown文件中的資料\nexport const getAllPosts: Function = (): Post[] => {\n    if ( posts.length === 0 ) {\n        const slugs = fs.readdirSync(postsDirectory);\n        posts = slugs.map((slug) => {\n            return getPost(slug);\n        });\n    }\n\n    return posts;\n};\n```\n\n## 文章列表\n\n有了這些，就可以把文章列表的部分印出來了！\n\n```typescript jsx\nexport const getStaticProps: GetStaticProps = async (context: GetStaticPropsContext<ParsedUrlQuery>): Promise<any> => {\n    const posts: Post[] = getAllPosts();\n    return {\n        props: {\n            posts: posts.slice(0, 10)\n        },\n    };\n};\n```\n\n## 文章內文\n\n接下來要讀取markdown中的內容，並且渲染出整個html，然後我也有針對markdwon的element做客制處理，例如`h1`的渲染就會如同下方的html\n\n```typescript jsx\nexport const h1 = (props: any) => {\n    const {children} = props;\n\n    return <div className={classNames(\"u-heading-v3\", \"g-mb-40\")}>\n        <h1 className={classNames(\"h1\", \"u-heading-v3__title\")}>\n            {children}\n        </h1>\n    </div>\n}\n```\n\n另外官方給的方式，渲染移植會有錯誤（如下圖），所以自己做了一個呈現的頁面，讓畫面可以有更完整的客製化功能\n\n![渲染錯誤](gatsbyjs-to-nextjs/render-error.png)\n\n```typescript jsx\nimport { NextPage } from 'next';\nimport ReactMarkdown from 'react-markdown';\n\nconst Posts: NextPage = (props: any) => {\n    return <>\n        <div className={ classNames('g-mb-30') }>\n             {/*略*/}\n            <ReactMarkdown components={ connponents }>{ props.content }</ReactMarkdown>\n        </div>\n        {/*略*/}\n    </>;\n};\n\nexport const getStaticProps: GetStaticProps = async ({ params }: any): Promise<any>  => {\n    const post = getPost(`${params.post[3]}.mdx`);\n    return {\n        props: {\n            ...post\n        },\n    };\n};\n\nexport const getStaticPaths: GetStaticPaths = async (): Promise<any>  => {\n    const posts = getAllPosts();\n    return {\n        paths: posts.map((post: Post) => {\n            return {\n                params: {\n                    post: post.url.split('/').map(i => i.toString()),\n                },\n            };\n        }),\n        fallback: false,\n    };\n};\n```\n\n## Tag標籤\n\n在Gatsby.js可以透過gql把文章標籤弄出來但在next.js中就只能自己處理了..\n\n我先在posts.ts中新加一個method，可以處理把文章的tag都列出來，然後在每一頁中添加印出tag的處理，這樣子就把原本Gatsby原有的功能做出來了！接下來差了分頁功能...\n\n```typescript\n// posts.ts\nexport const getTags: Function = (): { [index: string]: number } => {\n    const tags: { [index: string]: number } = {};\n    posts.forEach((post: Post) => {\n        post.tags.forEach((tag: string) => {\n            if ( tags[tag] === undefined ) {\n                tags[tag] = 1;\n            } else {\n                tags[tag]++;\n            }\n        });\n    });\n\n    return tags;\n};\n\n// pages/*\nexport const getStaticProps: GetStaticProps = async ({ params }: any): Promise<any>  => {\n    // 略\n    const allTags = getTags();\n    return {\n        props: {\n            // 略\n            allTags\n        },\n    };\n};\n```\n\n## 關於分頁功能\n\n每一頁只顯示10篇文章，所以在`index.tsx`先hard code 只取得文章前10筆，接下來再運用`getStaticPaths`的方式就可以達成分頁功能了！\n\n```typescript jsx\nindex.tsx中的getStaticProps\nexport const getStaticProps: GetStaticProps = async (context: GetStaticPropsContext<ParsedUrlQuery>): Promise<any> => {\n    const posts: Post[] = getAllPosts();\n    const allTags = getTags();\n    return {\n        props: {\n            posts: posts.slice(0, 10),\n            allTags,\n            total: posts.length\n        },\n    };\n};\n\n// [page].tsx\nexport const getStaticProps: GetStaticProps = async (context: GetStaticPropsContext<ParsedUrlQuery>): Promise<any> => {\n    const {\n        page,\n    }: any = context.params;\n\n    const posts: Post[] = getAllPosts();\n    const allTags = getTags();\n\n    const current = parseInt(page ?? '0');\n\n    return {\n        props: {\n            current,\n            posts: posts.slice((current - 1) * 10, current * 10),\n            allTags,\n            total: posts.length,\n        },\n    };\n};\n\nexport const getStaticPaths: GetStaticPaths = async (): Promise<any> => {\n    const pages = [];\n    const posts: Post[] = getAllPosts();\n\n    for (let i = 0; i < posts.length / 10; i++) {\n        pages.push({\n                       params: {\n                           page: `${ i + 1 }`,\n                       },\n                   });\n    }\n\n    return {\n        paths: pages,\n        fallback: false,\n    };\n};\n```\n\n## 參考連結\n\n[Next.js Migrate from Gatsby.js](https://nextjs.org/docs/migrating/from-gatsby)\n"},{"id":1664841600,"fileName":"postgresql-insert-or-update","url":"2022/10/04/postgresql-insert-or-update","title":"Postgresql 的Merge語法","description":"在SQL Server中有一個語法是merge的語法，他可以根據特定的條件執行特定的操作，如資料存在就更新不存在就新增。 但在Postgresql中，似乎沒有merge的語法可以使用...但在程式理先去得資料在判斷是否更新或新增這樣的情境容易導致一些後遺症.... 在google後，其實有很多方式但...嘗試後只有這個方法是可行的，所以在這邊筆記一下","date":"2022-10-04T00:00:00.000Z","tags":["postgresql","database"],"published":true,"content":"\n在SQL Server中有一個語法是`merge`的語法，他可以根據特定的條件執行特定的操作，如資料存在就更新不存在就新增。\n但在Postgresql中，似乎沒有merge的語法可以使用...但在程式理先去得資料在判斷是否更新或新增這樣的情境容易導致一些後遺症....\n在google後，其實有很多方式但...嘗試後只有這個方法是可行的，所以在這邊筆記一下\n\n> postgresql的版本是13\n\n```plsql\nINSERT INTO public.table (user_id, name, email)\nVALUES (@userid, @username, @user_email)\nON CONFLICT (user_id)\n    DO UPDATE SET (name, email) = (@username, @user_email)\nWHERE members.user_id = @userid;\n```\n當table中user_id衝突時，就會自動執行update，這樣一來根SQL server中的merge語句就相同了！\n\n\n### 參考資料\n\n[postgresql insert](https://www.postgresql.org/docs/current/sql-insert.html)\n"},{"id":1664496000,"fileName":"postgresql-dapper-json-deserialize","url":"2022/09/30/postgresql-dapper-json-deserialize","title":"透過Dapper存取Postgresql Json column 自動反序列化","description":"有時候一個物件我會把它序列化後使用JSON的方式存放到postgresql中，但把它取出後卻無法透過ORM直接做資料的對應，然後自己就土炮了做法， 把資料撈出後在針對欄位去反序列化，這樣做一開始覺得好像沒什麼，但這樣的資料變多了以後發現問體頗大，所以上網找了一些解決方案， 但關鍵字嚇得不好反而找到許多更奇怪的做法後來在stackoverflow上看到了這招真心覺得很棒的方法，於是筆記下來！","tags":["database","dotnet"],"date":"2022-09-30T00:00:00.000Z","published":true,"content":"\n有時候一個物件我會把它序列化後使用JSON的方式存放到postgresql中，但把它取出後卻無法透過ORM直接做資料的對應，然後自己就土炮了做法，\n把資料撈出後在針對欄位去反序列化，這樣做一開始覺得好像沒什麼，但這樣的資料變多了以後發現問體頗大，所以上網找了一些解決方案，\n但關鍵字嚇得不好反而找到許多更奇怪的做法後來在stackoverflow上看到了這招真心覺得很棒的方法，於是筆記下來！\n\n當初也有嘗試過使用`CustomPropertyTypeMap`來處理，但這個對於欄位與Class屬性名稱對應不同時使用，\n當欄位資料需要做特殊的轉換時就需要Dapper的ITypeHandler來定義什麼樣的資料型別需要怎麼去做處理，\n所以建立了一個class去繼承 `SqlMapper.ITypeHandler`然後實作類似Get/Set的物件存取的方式。\n\n```cs\npublic class JsonTypeHandler : SqlMapper.ITypeHandler\n{\n    public void SetValue(IDbDataParameter parameter, object value)\n    {\n        parameter.Value = JsonSerializer.Serialize(value);\n    }\n\n    public object Parse(Type destinationType, object value)\n    {\n        return value == null ? destinationType : JsonSerializer.Deserialize(value.ToString()!, destinationType);\n    }\n}\n```\n\n做好了這樣的物件後，只要在資料庫的連線物件上註冊`當遇到xxxx`型別時，使用JsonTypeHandler做處理，這樣一來就必須要土炮把資料撈出來後\n使用callback的方式做反序列化在僵值放回原本需要的物件中，減少了許多複雜的狀態。\n\n```cs\npublic class DbContext\n{\n    private string connectionString;\n    private readonly ILogger<DbContext> logger;\n\n    public DbContext(IServiceProvider provider)\n    {\n        略...\n\n        // 先決定目標的型別，再來把相對應的處理方式填上就行了\n        SqlMapper.AddTypeHandler(typeof(Dictionary<string, string>), new JsonTypeHandler());\n    }\n\n    /// 略...\n}\n```\n\n## 參考資料\n\n[can-dapper-deserialize-json-stored-as-text](https://stackoverflow.com/questions/49888334/can-dapper-deserialize-json-stored-as-text)\n"},{"id":1658793600,"fileName":"from-dark-age-to-mondern-deployment","url":"2022/07/26/from-dark-age-to-mondern-deployment","title":"從黑暗時代到現代化的雲端部署與維運 July 26 @ DevOps","description":"從黑暗時代到現代化的雲端部署與維運 July 26 @ DevOps","tags":["aws","devops","prevision"],"date":"2022-07-26T00:00:00.000Z","published":true,"content":"\n從黑暗時代到現代化的雲端部署與維運 July 26 @ DevOps\n\n[投影片下載](https://cdn.adhome.com.tw/blogger/從黑暗時代到現代化的雲端部署與維運July-26@DevOps.pdf)\n\n### 影片\n\n[YouTube 直播回放](https://www.youtube.com/watch?v=M0Am63ehgvE&ab_channel=DevOpsTaiwan)\n\n### 參考資料\n\n[如何讓AWS EC2開機後就能上線](https://brunojan.net/posts/2020/12/09/ec2-provisioned-self-install)\n"},{"id":1654732800,"fileName":"nodemcu-esp8266-platformio-with-clion","url":"2022/06/09/nodemcu-esp8266-platformio-with-clion","title":"使用Clion搭配platformio開發esp8266","description":"最近想把家中的電器可以跟apple homekit結合在一起省去一些麻煩順便可以帶來生活更好的狀態，但apple homekit的冷氣控制一個就要3700原， 對於家中有六台冷氣的我有點小貴，所以決定自己開發這樣的產品...順便也改造一下不太好用的窗簾機器人，讓他可以直接支援apple homekit，不需要再透過`捷徑`的方式來支援homekit\n在開始之前研究了一下許多arduino與Raspberry Pi兩者之間的選擇，發現了arduino在整個生態系來說完整不少，缺點是他基本上只支援C/C++的開發... Raspberry Pi 倒是可以使用.net或是node.js等等的語言，但許多的控制器或是傳感器支援的數量較少，並且價格也比較昂貴所以最後選擇了arduino， arduino中也有許多不同的板子，在選擇的時候的非常的困擾...後來我選擇了由樂鑫開發的ESP系列的板子好處是他已經內建了wifi功能， 所以可以直接使用不需要再加上wifi模組！","date":"2022-06-09T00:00:00.000Z","tags":["iot","platformio","arduino","esp"],"published":true,"content":"\n最近想把家中的電器可以跟apple homekit結合在一起省去一些麻煩順便可以帶來生活更好的狀態，但apple homekit的冷氣控制一個就要3700原，\n對於家中有六台冷氣的我有點小貴，所以決定自己開發這樣的產品...順便也改造一下不太好用的窗簾機器人，讓他可以直接支援apple homekit，不需要再透過`捷徑`的方式來支援homekit\n\n在開始之前研究了一下許多arduino與Raspberry Pi兩者之間的選擇，發現了arduino在整個生態系來說完整不少，缺點是他基本上只支援C/C++的開發...\nRaspberry Pi 倒是可以使用.net或是node.js等等的語言，但許多的控制器或是傳感器支援的數量較少，並且價格也比較昂貴所以最後選擇了arduino，\narduino中也有許多不同的板子，在選擇的時候的非常的困擾...後來我選擇了由樂鑫開發的ESP系列的板子好處是他已經內建了wifi功能，\n所以可以直接使用不需要再加上wifi模組！\n\n### CLion Plugin設定\n\nJetBrains開發工具真的都不錯所以我開發iot時我也選用了JetBrains的工具，在研究的時候也有人使用vs code跟arduino IDE來開發，CLion的安裝過程就不在這邊說了\n\nCLion在開發arduino必要安裝的套件有兩個，一個是`Arduino Support`另一個是`PlatformIO for CLion`這兩個就是圖片中第一個與第五個plugin，其他的你可以選用來安裝。\n\n![已安裝的CLion Plugins](nodemcu-esp8266-platformio-with-clion/plugins.png)\n\n### PlatformIO cli 安裝\n\n系統安裝需要有python3，在mac中已經有內建的python3，所以透過pip安裝platformio就可以或是透過Homebrew安裝也可以\n\n```shell\n# PIP install\npip3 install platformio\n# Homebrew 安裝\nbrew install platformio\n```\n> 透過python安裝時，一定要使用python 3.8以上的版本，不然會失敗\n\n### 新增專案\n\nESP8266是NodeMCU ESP-12E的版本，所以這邊選擇NodeMCU下的ESP-12E的專案類型\n\n![CLion 新增專案](https://cdn.adhome.com.tw/blogger/nodemcu-esp8266-platformio-with-clion/new-project.png)\n\n建立完成後就會看到下面這張圖片的狀態一樣，接下來只要把程式碼寫到`src/main.cpp`就可以上傳到ESP8266的板子上了！\n\n![CLion 專案初始](https://cdn.adhome.com.tw/blogger/nodemcu-esp8266-platformio-with-clion/project-init-folder.png)\n"},{"id":1654041600,"fileName":"arduino-use-platformio-upload-error","url":"2022/06/01/arduino-use-platformio-upload-error","title":"使用platformio上傳arduino時出現錯誤代碼(0107)","description":"第一次接觸arduino，很開心地寫下了一個閃爍板子上的LED程式碼後要上傳到板子，結果上傳時發生了錯誤 出現了Failed to write to target RAM (result was 0107)這樣的錯誤代碼，試了網路上很多的方式都沒有成功，最後發現了原來serial port 不正確...","date":"2022-06-01T00:00:00.000Z","tags":["iot","platformio","arduino"],"published":true,"content":"\n第一次接觸arduino，很開心地寫下了一個閃爍板子上的LED程式碼後要上傳到板子，結果上傳時發生了錯誤\n出現了Failed to write to target RAM (result was 0107)這樣的錯誤代碼，試了網路上很多的方式都沒有成功，最後發現了原來serial port\n不正確...\n\n以下是上傳時發生的錯誤訊息資料\n```text\n/usr/local/bin/platformio -c clion run --target upload -e nodemcuv2\nProcessing nodemcuv2 (platform: espressif8266; board: nodemcuv2; framework: arduino)\n\nVerbose mode can be enabled via `-v, --verbose` option\nCONFIGURATION: https://docs.platformio.org/page/boards/espressif8266/nodemcuv2.html\nPLATFORM: Espressif 8266 (3.2.0) > NodeMCU 1.0 (ESP-12E Module)\nHARDWARE: ESP8266 80MHz, 80KB RAM, 4MB Flash\nPACKAGES:\n - framework-arduinoespressif8266 @ 3.30002.0 (3.0.2)\n - tool-esptool @ 1.413.0 (4.13)\n - tool-esptoolpy @ 1.30000.201119 (3.0.0)\n - tool-mklittlefs @ 1.203.210628 (2.3)\n - tool-mkspiffs @ 1.200.0 (2.0)\n - toolchain-xtensa @ 2.100300.210717 (10.3.0)\nLDF: Library Dependency Finder -> https://bit.ly/configure-pio-ldf\nLDF Modes: Finder ~ chain, Compatibility ~ soft\nFound 35 compatible libraries\nScanning dependencies...\nNo dependencies\nBuilding in release mode\nRetrieving maximum program size .pio/build/nodemcuv2/firmware.elf\nChecking size .pio/build/nodemcuv2/firmware.elf\nAdvanced Memory Usage is available via \"PlatformIO Home > Project Inspect\"\nRAM:   [===       ]  34.2% (used 28032 bytes from 81920 bytes)\nFlash: [===       ]  25.4% (used 265729 bytes from 1044464 bytes)\nConfiguring upload protocol...\nAVAILABLE: espota, esptool\nCURRENT: upload_protocol = esptool\nLooking for upload port...\nAuto-detected: /dev/cu.usbmodem53770161961\nUploading .pio/build/nodemcuv2/firmware.bin\nesptool.py v3.0\nSerial port /dev/cu.usbmodem53770161961\nConnecting....\nChip is ESP8266EX\nFeatures: WiFi\nCrystal is 26MHz\nMAC: e8:db:84:df:34:f7\nUploading stub...\n\nA fatal error occurred: Failed to write to target RAM (result was 0107)\n*** [upload] Error 2\n [FAILED] Took 2.01 seconds\n\nProcess finished with exit code 1\n```\n\n### 確認線材\n\n因為板子上的usb介面事mirco usb的介面，這個介面很多的線材是只有充電功能而已無法做資料傳輸，所以...首先要先確定你的線材是不是可以做資料傳輸的用途，\n否則做了再多的工作可能都無法上傳成功\n\n因此我還上了pchome購買了usb type-c to mirco usb的資料傳輸線...\n\n### 驅動程式\n\n我使用的板子是nodeMCU ESP-12E(ESP-8266的板子，晶片是CH9102X)，搭配的事CLion的IDE開發工具\n\n在網路上找到的問題主要都是第一次上傳到板子沒有安裝相對應的驅動程式所以導致錯誤發生，如果發生這個狀態好解決，安裝相對應的驅動程式就可以解決了\nESP8266的晶片有兩種一種是CH9102另一種是CP2102，網路上搜尋的時候還會出現CH340相關的資料，CH340跟CH9102是相同的所以安裝的時候可以找到CH34x的驅動安裝後即可\n但...如果還是不行，可以先確定一下電腦是否有抓到板子在做下一步\n\n```shell\npio device list\n```\n以下是我的output資訊，有看到`/dev/cu.xxxxxx`的資料，就表示真的有抓到板子囉！但如果看到了這樣的輸出，還是出現了\n`A fatal error occurred: Failed to write to target RAM (result was 0107)`的錯誤，該怎麼辦？\n\n```shell\n/dev/cu.BLTH\n------------\nHardware ID: n/a\nDescription: n/a\n\n/dev/cu.Bluetooth-Incoming-Port\n-------------------------------\nHardware ID: n/a\nDescription: n/a\n\n/dev/cu.wchusbserial53770161961\n-------------------------------\nHardware ID: USB VID:PID=1A86:55D4 SER=5377016196 LOCATION=20-2\nDescription: USB Single Serial\n\n/dev/cu.usbmodem53770161961\n---------------------------\nHardware ID: USB VID:PID=1A86:55D4 SER=5377016196 LOCATION=20-2\nDescription: USB Single Serial\n```\n\n### 確認upload port的設定\n\n安裝驅動跟確認線材的問題我卡了許久，也確認了許多次數後我發現我的輸出錯誤都是在使用`/dev/cu.usbmodem53770161961`這個serial port上傳，\n然後偶爾會出現資院忙碌中的錯誤\n```shell\ncould not open port '/dev/cu.usbmodem53770161961': [Errno 16] could not open port /dev/cu.usbmodem53770161961: [Errno 16] Resource busy:.....\n```\n\n在查詢資料過程中想起了一個設定，那就是指定上傳的serial port想說隨便試試看是不是因為serial port的問題...畢竟每次都卡在同一個port上乾脆換一個試試看\n所以我在platfromio.ini這個檔案上增加了一行upload_port的設定，沒想到就出現成功的資訊了！如果你在pio device list看到兩個port這個方法可以試試看，或許有用\n\n```text\n[env:nodemcuv2]\nplatform = espressif8266\nboard = nodemcuv2\nframework = arduino\nupload_port = /dev/cu.wchusbserial53770161961\n```\n"},{"id":1653004800,"fileName":"self-hosted-elasticsearch-8.2","url":"2022/05/20/self-hosted-elasticsearch-8.2","title":"自建Elasticsearch 8.2","description":"這週在處理自建的elasticsearch相關的狀況，今天處理告一段落後來個小筆記未來遇到才不會又搞了老半天...","date":"2022-05-20T00:00:00.000Z","tags":["elk","prevision"],"published":true,"content":"\n這週在處理在azure自建的elasticsearch相關的狀況，今天處理告一段落後來個小筆記未來遇到才不會又搞了老半天...\n\n為什麼要自建elastic呢？主要因為之前使用azure marketplace建立的elastic cloud的saas服務，現在需要把維運的職責交給SRE團隊，\n在移交的過程中發現了azure marketplace所建立的saas服務竟然不能移轉owner！只能將該服務的權限做共享而且必須將訂閱升級到Golden的等級，\n代表每個月的azure帳單又要多最少百元美金的支出...未來帳號如果被停用或是變更，有可能elastic cloud上的資料會有所影響，迫於無奈下只好走向自建的路了\n\n在自建時需要選好許多azure的服務相關的infra設計這些工作可少不了...最後決定了這些infra與azure的服務\n\n#### 1. elasticsearch server + kibana server\n\n使用vmss的服務建立虛擬機器，虛擬機器的規格是使用E2s v5的規格，根據過往經驗elasticsearch伺服器在尖峰的狀態下會使用較多的記憶體，而對於cpu要求較少一些\n對於網路的頻寬要求與對於硬碟的iops都有較大的要求，所以選用了esv5等級的機器\n\n#### 2. logstash server\n\nlogstash 服務也是採用vmss來建立虛擬機器，比較不一樣的是logstash對於cpu的要求較多，他需要去解析log還要針對log做相對應的處理，所以我們選用的是B1s的規格\n然後針對他cpu與memory的使用率做scale out/in的處理\n\n在主機中我使用的是container而非直接安裝相關的服務，然後搭配過去preversion的手法來建立伺服器。\n\n#### 3. Storage\n\n存放資料的磁區選用，這個在規劃時的poc最為困擾...在azure直接使用virtual machine的服務可以掛載managed disk的磁區，但使用vmss產生的vm是無法使用managed disk的！\n但...vmss或是vm建立的硬碟會隨這vm刪除或關閉而消失，所以我們必須得用另外一組的硬碟...後來找到了另外一種解決方案，azure file的服務，\n這樣一來就可以透過SMB掛載一個永久的硬碟，未來的log就能完整地被保留下來不會因為vm被刪除而消彌。\n\n> ps. azure file目前還不知道這樣的使用情境可以支撐多少的iops寫入與讀取，有待未來實驗\n> 根據官方文件指出每秒的iops是20,000 IOPS的讀取的速度基本上可以跟SSD差不多\n\n### 內建帳號使用 Service account token\n\n在使用8.0過後的版本kibana的服務官方預設不使用帳號密碼的方式登入，需要使用service account token的方式登入連線，然後按照官方的指引點入的連結會請你呼叫建立token的api\n```sh\n# create service account token\ncurl -X POST -u elastic:changeme \"localhost:9200/_security/service/elastic/fleet-server/credential/token?pretty\"\n```\nresponse\n```json\n{\n  \"created\": true,\n  \"token\": {\n    \"name\": \"token1\",\n    \"value\": \"AAEAAWVsYXN0aWM...vZmxlZXQtc2VydmVyL3Rva2VuMTo3TFdaSDZ\"\n  }\n}\n```\n然後在kibana上使用service account token登入，但只使用這樣的方式建立的token放在kibana上使用是可以登入elasticsearch，\n但在操作indices的時候就會出現錯誤`security_exception`說你沒有權限取得indices的資料\n```yaml\n# kibana.yml config\nserver.name: kibana\nserver.host: 0.0.0.0\nelasticsearch.hosts: [ \"http://{{elasticsearch}}:{{port}}\" ]\nxpack.monitoring.ui.container.elasticsearch.enabled: true\n\nelasticsearch.serviceAccountToken: AAEAAWVs......EtHd1E\n```\n好的，後來發現其實api呼叫的參數不對，官方在錯誤輸出的console上給的網址是會呼叫fleet-server的服務，而不是給kibana使用的所以我們要把fleet-server的token\n改成kibana服務的token，這樣就可以登入並且取得indices的資料順利的啟動kibana了\n```shell\n# for create kibana service account\ncurl -X POST -u elastic:changeme \"localhost:9200/_security/service/elastic/kibana/credential/token?pretty\"\n```\n```shell\n# check permission\ncurl -H \"Authorization: Bearer AAE.......1E\" -X GET \"localhost:9200/_security/user/_has_privileges?pretty\" -H 'Content-Type: application/json' -d'\n{\n  \"cluster\": [ \"cluster:monitor/main\" ],\n  \"index\" : [\n    {\n      \"names\": [ \"logs-apm.app-default\", \"metrics-apm.app.*-default\", \"logs-apm.error-default\", \"metrics-apm.internal-default\", \"metrics-apm.profiling-default\", \"traces-apm.rum-default\", \"traces-apm-default\" ],\n      \"privileges\": [ \"auto_configure\",\"create_doc\" ]\n    },\n    {\n      \"names\": [ \"traces-apm.sampled-default\" ],\n      \"privileges\": [ \"auto_configure\",\"create_doc\",\"maintenance\",\"monitor\",\"read\" ]\n    }\n  ]\n}\n'\n```\n\n## 後記\n\n因為azure file使用`Transaction optimized`等級的價格每GB花費是1.763台幣，價格並不便宜所以只能將hot data存放在該區域中，\n在未來會放上elastic使用cluster的方式將hot data與warm data（使用hot等級）區分開來，減少帳單的開支\n\n## 參考連結\n\n[Service Accounts (Official document)](https://www.elastic.co/guide/en/elasticsearch/reference/current/service-accounts.html)\n\n[Create service account token api (official document)](https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-service-token.html)\n\n[azure file iops](https://docs.microsoft.com/en-us/azure/storage/files/storage-files-scale-targets)\n"}],"allTags":{"devops":8,"study4":2,"dotnetconf":2,"aws":5,"frontend":2,"next.js":4,"react":5,"i18n":1,"gatsby.js":1,"postgresql":1,"database":2,"dotnet":1,"prevision":6,"iot":2,"platformio":2,"arduino":2,"esp":1,"elk":3,"azure":4,"vulnerability":1,"ssl":2,"vmss":1,"cd":3,"selenium":2,"tdd":1,"jest":1,"layout":1,"ec2":1,"iac":1,"terraform":1,"ci":1,"jenkins":1,"ecs":1,"ansible":1,"redis":2,"protobuf":2,"serialize":2,"deserialize":2,"pub":1,"sub":1,"notify":1},"total":28},"__N_SSG":true}