{"pageProps":{"posts":[{"id":1650412800,"fileName":"azure-self-install","url":"2022/04/20/azure-self-install","title":"Azure 的自動裝機","description":"在之前已經有寫過AWS的裝機處理，這次改用Azure同樣的可以讓系統從scale out到上線不需要人工的處理就可以完成系統的部署與設定","date":"2022-04-20T00:00:00.000Z","tags":["devops","azure","prevision"],"published":true,"content":"\n在之前已經有寫過AWS的裝機處理，這次改用Azure同樣的可以讓系統從scale out到上線不需要人工的處理就可以完成系統的部署與設定\n\n## Azure 的VM Scale Set\n\n在AWS是稱為Auto Scaling Group，在Azure中的名稱是Virtual Machine Scale Set(以下簡稱VMSS)，這也是一個群組設定虛擬機器的規格, 伸縮的條件, 健康檢查等等的設定\n\ncustom_data的資料就是我們準備要設定開機後要執行的腳本，這個設定了以後在azure 的Portal是無法再看到的，所以如果不是使用IaC的話一定要找個地方做紀錄\nAzure的VMSS就有內建的檢查機制(extension區塊)，可以檢查VM的服務是否正確地被啟動，若沒有在時間內被測試成功的話機器會重新收回部署\n\n在terraform 有另一個設定 extension的module， `azurerm_virtual_machine_extension`設定如果要設定`healthRepairExtension`在我測試時是會失敗的，所以一定要在extension區塊中設定。\n\n```config\nresource \"azurerm_linux_virtual_machine_scale_set\" \"sample\" {\n  name                = \"${var.prefix}-vmss\"\n  resource_group_name = data.azurerm_resource_group.main.name\n  location            = data.azurerm_resource_group.main.location\n  zone_balance        = true\n  zones               = [1, 2, 3]\n  sku                 = var.machineSize\n  instances           = var.capacity.minimum\n  admin_username      = \"azureuser\"\n  custom_data         = filebase64(\"${path.module}/custom-data.sh\")\n\n  admin_ssh_key {\n    username   = \"azureuser\"\n    public_key = data.azurerm_ssh_public_key.logstash.public_key\n  }\n\n  automatic_instance_repair {\n    enabled      = true\n    grace_period = \"PT10M\"\n  }\n\n  source_image_reference {\n    publisher = \"canonical\"\n    offer     = \"0001-com-ubuntu-server-focal\"\n    sku       = \"20_04-lts-gen2\"\n    version   = \"latest\"\n  }\n\n  os_disk {\n    storage_account_type = \"Standard_LRS\"\n    caching              = \"ReadWrite\"\n    disk_size_gb         = 30\n  }\n\n  extension {\n    name                      = \"healthRepairExtension\"\n    publisher                 = \"Microsoft.ManagedServices\"\n    type                      = \"ApplicationHealthLinux\"\n    type_handler_version      = \"1.0\"\n    automatic_upgrade_enabled = true\n    settings                  = <<settings\n      {\n        \"protocol\" : \"http\",\n        \"port\" : 80,\n        \"requestPath\" : \"/\"\n      }\n    settings\n  }\n\n  network_interface {\n    name    = \"${var.prefix}-NIC\"\n    primary = true\n\n    ip_configuration {\n      name      = \"internal\"\n      primary   = true\n      subnet_id = azurerm_subnet.subnet.id\n    }\n  }\n\n  tags = {\n    env      = var.environment\n    service  = \"logstash\"\n    createby = \"brunojan\"\n    docker   = \"yes\"\n    date     = formatdate(\"YYYY/MM/DD hh:mm:ss\", timestamp())\n    version  = var.ap_version\n  }\n}\n```\n## VMSS的擴展計畫\n\n在Azure的設定呢，說真的我還沒有非常的理解整個設定，但目前看起來的設定較為麻煩...\n\n在Profile中，一定要有一組預設的設定資料，接下來才能在設定其他的擴展策略，所以我直接hard code一組default的設定，這個設定會是主要的擴展策略。\n其他的設定基本上可以依照特定的時間，或是情境來做設定\n\n在設定中的時間設定在Azure都是使用ISO-8601的設定標準來設定，這個部份對於我來說真的很不順手，也不容易理解...\n\n```config\nresource \"azurerm_monitor_autoscale_setting\" \"autoscale\" {\n  name                = \"${var.prefix}-scale-set\"\n  resource_group_name = data.azurerm_resource_group.main.name\n  location            = data.azurerm_resource_group.main.location\n  target_resource_id  = azurerm_linux_virtual_machine_scale_set.sample.id\n\n  profile {\n    name = \"default\"\n\n    capacity {\n      default = var.capacity.minimum\n      minimum = var.capacity.minimum\n      maximum = var.capacity.maximum\n    }\n\n    dynamic \"rule\" {\n      for_each = length(var.policies) > 0 ? var.policies : []\n      content {\n        metric_trigger {\n          metric_name        = rule.value.metric\n          metric_resource_id = azurerm_linux_virtual_machine_scale_set.sample.id\n          time_grain         = rule.value.grain\n          statistic          = rule.value.statistic\n          time_window        = rule.value.duration\n          time_aggregation   = rule.value.statistic\n          operator           = rule.value.operation\n          threshold          = rule.value.threshold\n          metric_namespace   = \"microsoft.compute/virtualmachinescalesets\"\n        }\n\n        scale_action {\n          direction = rule.value.action\n          type      = \"ChangeCount\"\n          value     = rule.value.count\n          cooldown  = rule.value.cooldown\n        }\n      }\n    }\n  }\n\n  dynamic \"profile\" {\n    for_each = length(var.schedules) > 0 ? var.schedules : []\n\n    content {\n      name = profile.value.name\n\n      capacity {\n        default = profile.value.minimum\n        minimum = profile.value.minimum\n        maximum = profile.value.maximum\n      }\n\n      recurrence {\n        timezone = \"Taipei Standard Time\"\n        days     = profile.value.days\n        hours    = profile.value.hours\n        minutes  = profile.value.minutes\n      }\n\n    }\n  }\n```\n\n## Terraform azurerm_virtual_machine_scale_set\n\n這個在未來的版本中已經被棄用了，所以如果有要使用terraform的記得改用`azurerm_linux_virtual_machine_scale_set`(Linux)與azurerm_windows_virtual_machine_scale_set(Windows)\n設定上基本差不多\n\n## 參考資料\n\n[ISO-8601 wiki](https://en.wikipedia.org/wiki/ISO_8601)\n\n[Terraform azurerm_virtual_machine_scale_set](https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/virtual_machine_scale_set)\n"},{"id":1639958400,"fileName":"dotnetconf-2021@study4","url":"2021/12/20/dotnetconf-2021@study4","title":"從黑暗時代到現代化的雲端部署與維運","description":"dotnetconf 2021 ＠ study4 從黑暗時代到現代化的雲端部署與維運","tags":["azure","vmss","cd","devops","prevision","study4","dotnetconf"],"date":"2021-12-20T00:00:00.000Z","published":true,"content":"\ndotnetconf 2021 ＠ study4 從黑暗時代到現代化的雲端部署與維運\n\n[投影片下載](https://cdn.adhome.com.tw/blogger/dotnetconf2021@STUDY4.pdf)\n\n## IAC 說明\n\n[IaC Repo](https://github.com/Yi-Shiuan/dotnet-conf-iac)\n\n### website 資料夾\n\nwebsite資料夾是建立各個環境的資源檔案，內容記載該服務需要產生哪些的資源項目以及各個環境上的配置，裡面的部分採用terraform撰寫\n\n- `main.tf` => 用來設定資院建立的內容與設定\n- `variable.tf` => 定義整個腳本中有哪些變數\n- `vars 資料夾` => 每一個環境上的設定值\n\n### initial-script\n\n自動安裝腳本，這裡面的`main.sh`是整個警本的進入點，每一個服務都會有一個資料夾，資料夾內會有一個`install.sh`的檔案，這是實際上application真正執行部署的腳本\n由main.sh去下載install.sh，並且執行install.sh\n\n\n"},{"id":1635552000,"fileName":"logstash-azure-event-hub-input","url":"2021/10/30/logstash-azure-event-hub-input","title":"Logstash Azure event hub input 設定","description":"最近又在規劃ELK的設定，這次比較不一樣的地方我選擇了elastic cloud以及服務部署的方式都採用PaaS的方式作為部署， 加掛volume或是在機器上安裝filebeat都是一個比較困難的事情，所以一開始考慮使用azure blob queue的方式存放log， 但後來選擇了官方有提供的input套件，Azure Event Hub來寫log在使用logstash去讀取傳送到elasticsearch上","date":"2021-10-30T00:00:00.000Z","tags":["azure","elk"],"published":true,"content":"\n最近又在規劃ELK的設定，這次比較不一樣的地方我選擇了elastic cloud以及服務部署的方式都採用PaaS的方式作為部署，\n加掛volume或是在機器上安裝filebeat都是一個比較困難的事情，所以一開始考慮使用azure blob queue的方式存放log，\n但後來選擇了官方有提供的input套件，Azure Event Hub來寫log在使用logstash去讀取傳送到elasticsearch上\n\n根據官網的文件操作後會一直出現\n`The configuration will result in overwriting offsets. Please ensure that the each Event Hub's consumer_group is using a unique storage container.`\n這樣的錯誤訊息，也採用了進階的設定去使用，但因為只有一組採用進階的方式設定有點太過複雜所以又改回原本設定，後來想我的event hub的connection string有兩組會不會因為這樣我需要多個storage container的存放空間，\n後來將其中一組刪除後即可正常運作\n\n```config\n# 會出錯的logstash pipeline config\ninput {\n    azure_event_hubs {\n        event_hub_connections => [\"Endpoint=sb://<<event hub>>.servicebus.windows.net/;SharedAccessKeyName=logsta...\",\n            \"Endpoint=sb://<<event hub>>.servicebus.windows.net/;SharedAccessKeyName=logsta...\"]\n        storage_connection => \"DefaultEndpointsProtocol=https;...\"\n        consumer_group => \"logstash\"\n        decorate_events => true\n        threads => 8\n    }\n}\nfilter {\n    json {\n        source => \"message\"\n    }\n    date {\n        match => [ \"Timestamp\", \"ISO8601\" ]\n        target => \"@timestamp\"\n    }\n    mutate {\n        rename => [\"MessageTemplate\", \"message\" ]\n        rename => [\"Level\", \"level\" ]\n        merge => { \"message\" => \"Exception\" }\n        remove_field => [\"Exception\", \"Timestamp\"]\n    }\n}\noutput {\n    elasticsearch {\n        cloud_id => \"<<Cloud id>>\"\n        cloud_auth => \"<<user>>:<<password>>\"\n        index => \"demo-%{+YYYY.w}\"\n    }\n}\n```\n\n```config\n# 最後的 logstash pipeline config\ninput {\n    azure_event_hubs {\n        event_hub_connections => [\"Endpoint=sb://<<event hub>>.servicebus.windows.net/;SharedAccessKeyName=logsta...\"]\n        storage_connection => \"DefaultEndpointsProtocol=https;...\"\n        consumer_group => \"logstash\"\n        decorate_events => true\n        threads => 8\n    }\n}\nfilter {\n    json {\n        source => \"message\"\n    }\n    date {\n        match => [ \"Timestamp\", \"ISO8601\" ]\n        target => \"@timestamp\"\n    }\n    mutate {\n        rename => [\"MessageTemplate\", \"message\" ]\n        rename => [\"Level\", \"level\" ]\n        merge => { \"message\" => \"Exception\" }\n        remove_field => [\"Exception\", \"Timestamp\"]\n    }\n}\noutput {\n    elasticsearch {\n        cloud_id => \"<<Cloud id>>\"\n        cloud_auth => \"<<user>>:<<password>>\"\n        index => \"demo-%{+YYYY.w}\"\n    }\n}\n```\n\n\n### 參考資料\n[Github - logstash-input-azure_event_hubs](https://github.com/logstash-plugins/logstash-input-azure_event_hubs)\n"},{"id":1628812800,"fileName":"azure-managed-certificate-app-service","url":"2021/08/13/azure-managed-certificate-app-service","title":"受Azure管理的免費憑證","description":"在網頁開發中，SSL憑證已經是一個不可或缺的一件事情！網路上可以找到許多免費的憑證使用，如let's encrypt、ZeroSSL 都可以幫你產生免費的憑證，唯一麻煩的事情是三個月就需要重新處理憑證問題，在雲端供應商中AWS有提供ACM微軟也有提供類似於ACM的服務， 只要你使用了這些雲端供應商就可以免費的為你產生憑證","date":"2021-08-13T00:00:00.000Z","tags":["devops","azure","ssl"],"published":true,"content":"\n在網頁開發中，SSL憑證已經是一個不可或缺的一件事情！網路上可以找到許多免費的憑證使用，如[let's encrypt](https://letsencrypt.org/zh-tw/)、\n[ZeroSSL](https://zerossl.com/)都可以幫你產生免費的憑證，唯一麻煩的事情是三個月就需要重新處理憑證問題，當然熟悉腳本處理的可以透過一些自動化的方式來處理只是需要花點時間撰寫這些腳本\n在雲端供應商中AWS有提供ACM微軟也有提供類似於ACM的服務，只要你使用了這些雲端供應商就可以免費的為你產生憑證\n\n## 設定方式\n\nAzure 坦白說UI真的不是很直覺，這也是微軟一直以來的硬傷，這個設定其實藏在我們一直看得到的地方但又不會去點他的一個按鈕\n\n再進入設定之前，必須要將自訂的domain綁在Azure app service上（或Azure functions）才能夠產生憑證，點下`Create App Service Managed Certificate`\n後只需要點選你要的Domain 就可以產生了，整個過程約3-5分鐘左右，如果有多個子網域都需要SSL的話就多點幾次\n\n![Azure 受管的 SSL](azure-managed-certificate-app-service/azure-managed-ssl.png)\n\n![Azure 產生 SSL](azure-managed-certificate-app-service/create-ssl.png)\n\n產生SSL憑證後需要到`TSL/SSL Setting`中，將剛才建立的SSL綁定到相對應的Domain name上就可以了\n\n![Azure 綁定 SSL](azure-managed-certificate-app-service/azure-ssl-binding.png)\n\n## 使用條件與限制\n\n憑證一定位有到期日期，在微軟提供的憑證中有效期間是6個月，在六個月到期後會自動的幫你renew這個憑證直到你刪除app service或azure functions等服務，\n必須要可以自訂domain name的規格才能夠產生免費的憑證(B1等級以上)\n\n> 此免費憑證有下列限制：\n>\n>  - 不支援萬用字元憑證。\n>  - 不支援以憑證指紋作為用戶端憑證的使用方式， (移除憑證指紋的) 計畫。\n>  - 不可匯出。\n>  - App Service 環境 (ASE) 上並不支援。\n>  - 與流量管理員整合的根域不支援。\n>  - 如果是 CNAME 對應網域的憑證，則 CNAME 必須直接對應至 {app-name}.azurewebsites.net 。\n>\n> [在 Azure App Service 中新增 TLS/SSL 憑證](https://docs.microsoft.com/zh-tw/azure/app-service/configure-ssl-certificate)\n"}],"allTags":{"react":5,"next.js":3,"i18n":1,"gatsby.js":1,"postgresql":1,"database":2,"dotnet":1,"aws":4,"devops":7,"prevision":6,"iot":2,"platformio":2,"arduino":2,"esp":1,"elk":3,"azure":4,"vulnerability":1,"ssl":2,"vmss":1,"cd":3,"study4":1,"dotnetconf":1,"selenium":2,"tdd":1,"jest":1,"frontend":1,"layout":1,"ec2":1,"iac":1,"terraform":1,"ci":1,"jenkins":1,"ecs":1,"ansible":1,"redis":2,"protobuf":2,"serialize":2,"deserialize":2,"pub":1,"sub":1,"notify":1}},"__N_SSG":true}