{"pageProps":{"posts":[{"id":1670198400,"fileName":"nextjs-i18n-with-react-intl","url":"2022/12/05/nextjs-i18n-with-react-intl","title":"Next.JS 靜態網站 + React-Intl 的 i18n","description":"多國語系在許多網站已經是不可或缺的一個功能，在自己的研究中想做這事件情很久了，在公司的日常開發中也有許多這樣的功能，但前人已經設定好了，沒有從頭來過的感覺 剛好這兩天終於有一個契機與必要實作的需求出現了。於是就把自己實作的步驟記錄下來！","date":"2022-12-05T00:00:00.000Z","tags":["react","next.js","i18n"],"published":true,"content":"\n多國語系在許多網站已經是不可或缺的一個功能，在自己的研究中想做這事件情很久了，在公司的日常開發中也有許多這樣的功能，但前人已經設定好了，沒有從頭來過的感覺\n剛好這兩天終於有一個契機與必要實作的需求出現了。於是就把自己實作的步驟記錄下來！\n\n### 1. 安裝React-intl\n\n```bash\nyarn add react-intl\n```\n\n### 2. 設定next.config.js\n\n開啟next.config.js設定預設的語系以及支援的語系設定，locales是設定支援的語系檔案而 defaultLocale 當沒有傳入語系設定時所使用的預設語系\n\n```js\nmodule.exports = {\n  ...\n  i18n: {\n    locales: ['en', 'tw'],\n    defaultLocale: 'tw',\n  },\n  ...\n};\n```\n\n### 3. 放置語系包的位置\n\n在語系設定上我的檔案會放在`/src/locales`中，裡面的檔案要對應到在**next.config.js**中所設定的語系相同，網站中有需要用到多國語系的語系檔案都可以在這邊設定\n\n語系的檔案結構\n```txt\n.\n├── ...\n├── src\n│   ├── locales\n│   │   ├── en.ts\n│   │   ├── tw.ts\n│   │   └── index.ts\n│   ├── pages\n│   │   ├── _app.ts\n│   └── ...\n└── ...\n```\n語系資料對應後續我們就可以使用`FormattedMessage`的Component來取得該資料值。\n```typescript\n// en.ts檔案設定\nexport const en = {\n    my_title: `Bruno's Jan Tech blogger`\n}\n\n// tw.ts\nexport const tw = {\n    my_title: `Bruno's 技術筆記`\n}\n\n// index.ts\nimport { en } from \"./en\";\nimport { tw } from \"./tw\";\n\nexport const messages: any = {\n    tw,\n    en\n}\n```\n\n### 4. 設定_app.tsx檔案\n\n在_app.tsx中設定`IntlProvider`以及語系包的資料設定\n\n```tsx\nimport { AppProps } from 'next/app';\nimport { useRouter } from 'next/router';\nimport React, { ReactElement } from 'react';\nimport { IntlProvider } from 'react-intl';\nimport { messages } from '~/locales';\n\nconst App: any = ({\n                      Component,\n                      pageProps,\n                  }: AppProps) => {\n    const router = useRouter();\n    const {\n        locale,\n        defaultLocale,\n    } = router;\n    const message: any = messages[locale];\n    return <IntlProvider locale={ locale } defaultLocale={ 'tw' } messages={ message }>\n        <Component { ...pageProps } />\n    </IntlProvider>;\n};\n\nexport default App;\n```\n\n接下來就可以在畫面上需要多語言翻譯的位置加上下列程式碼就可以展現多國語系了！\n```tsx\nimport { FormattedMessage } from 'react-intl';\n\n\n<FormattedMessage id='my_title' defaultMessage='My default title' />\n```\n\n### 輸出靜態網站\n\n完成了多語系社的設定以後，當要輸出靜態網站時出現了錯誤...竟然說i18n不支援`next export`！\n\n```bash\n$ next export\ninfo  - using build directory: /Users/Yi-Shiuan/Documents/git/Blogger/.next\ninfo  - Copying \"static build\" directory\ninfo  - No \"exportPathMap\" found in \"/Users/Yi-Shiuan/Documents/git/Blogger/next.config.js\". Generating map from \"./pages\"\nError: i18n support is not compatible with next export. See here for more info on deploying: https://nextjs.org/docs/deployment\n    at /Users/Yi-Shiuan/Documents/git/Blogger/node_modules/next/dist/export/index.js:147:19\n    at async Span.traceAsyncFn (/Users/Yi-Shiuan/Documents/git/Blogger/node_modules/next/dist/trace/trace.js:79:20)\nerror Command failed with exit code 1.\ninfo Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\nerror Command failed with exit code 1.\ninfo Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\n```\n\n後來在官網中找到了這一段文字..\n\n> Note that Internationalized Routing does not integrate with next export as next export does not leverage the Next.js routing layer.\n> Hybrid Next.js applications that do not use next export are fully supported.\n>\n> [Next.js - Internationalized Routing](https://nextjs.org/docs/advanced-features/i18n-routing#limits-for-the-i18n-config)\n\n好吧，看起來我想輸出靜態網站不支援這樣的設定，所以只好動點手腳讓系統支援他！\n\n用靜態路由的設定來讓他可以支援多國語系\n\n```tsx\nexport const getStaticPaths: GetStaticPaths = async (): Promise<any> => {\n    return {\n        paths: [\n            { params: { lang: 'tw' } },\n            { params: { lang: 'en' } },\n        ],\n        fallback: false,\n    };\n};\n```\n再次修改_app.tsx\n\n使用路由取得語系，再去設定 `IntlProvider`載入的語系設定\n```tsx\nimport { AppProps } from 'next/app';\nimport { useRouter } from 'next/router';\nimport React, { ReactElement } from 'react';\nimport { IntlProvider } from 'react-intl';\nimport { messages } from '~/locales';\n\nconst App: any = ({\n                      Component,\n                      pageProps,\n                  }: AppProps) => {\n    library.add(fas, fab);\n    const router = useRouter();\n    const {\n        locale,\n        defaultLocale,\n    } = router;\n    const { lang } = router.query;\n    // @ts-ignore\n    const message: any = messages[lang ?? 'tw'];\n\n    return <IntlProvider locale={ locale ?? 'tw' } defaultLocale={ 'tw' } messages={ message }>\n        <Component { ...pageProps } />\n    </IntlProvider>;\n};\n\nexport default App;\n```\n\n最後移除next.config.js中的設定\n```js\n    i18n: {\n        locales: ['en', 'tw'],\n        defaultLocale: 'tw',\n    },\n```\n\n這樣就可以在靜態網站中擁有多國語系囉！\n\n### 參考資料\n\n[Next.js - Internationalized Routing](https://nextjs.org/docs/advanced-features/i18n-routing#limits-for-the-i18n-config)\n\n[Internationalizing Next.js app with react-intl by Iskren Lalov](https://www.laloov.com/posts/internationalizing-next-js-app-with-react-intl)\n"},{"id":1666224000,"fileName":"gatsbyjs-to-nextjs","url":"2022/10/20/gatsbyjs-to-nextjs","title":"從Gatsby.js轉換到Next.js","description":"紀錄從Gatsby.js轉換到了Next.js的踩地雷過程","date":"2022-10-20T00:00:00.000Z","tags":["react","gatsby.js","next.js"],"published":true,"content":"\n其實Gatsby.js並沒有什麼不好，只是他每一次改版都需要花費許多精力去做更新，我從1.0用到了3.0，最後4.0真的讓我痛下決心轉換到了Next.js的懷抱\n\n雖然官方有介紹如何從Gatsby.js遷移到Next.js的範例，但說真的還有許多沒有寫清楚的地方這邊先做幾個紀錄\n\n## 更新package.json\n\n除離移除所有的Gatsby.js的套件外，還需要安裝幾個套件這幾個套件官方都有說明主要是為了渲染markdown的文件以及讀取markdown的文件的套件功能\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"next build\",\n    \"export\": \"next export\",\n    \"dev\": \"next dev\",\n    \"start\": \"next start\"\n  },\n  \"subpath\": \"`/*\",\n  \"dependencies\": {\n    \"gray-matter\": \"^4.0.3\",\n    \"next\": \"^12.3.1\",\n    \"react-markdown\": \"^8.0.3\",\n    \"react-syntax-highlighter\": \"^15.4.4\",\n    \"remark\": \"^14.0.2\",\n    \"remark-html\": \"^15.0.1\"\n  }\n}\n```\n\n## 讀取markdown檔案\n\n在部落格中的markdown文件資料夾是這樣放的 `src/posts/{post}.mdx`\n\n```typescript\n// posts.ts\n\nimport dayjs from 'dayjs';\nimport fs from 'fs';\nimport matter from 'gray-matter';\nimport { join } from 'path';\n\nexport type Post = {\n    id: number;\n    fileName: string;\n    url: string;\n    title: string;\n    tags: string[];\n    content: string;\n    date: Date;\n    publish: boolean;\n    description: string;\n}\n\nconst postsDirectory = join(process.cwd(), '<<markdown 檔案位置>>');\nlet posts: Post[] = [];\n\n// 取得markdown文件中的內容\nexport const getPost: Function = (slug: string): Post => {\n    const realSlug = slug.replace(/\\.mdx$/, '');\n    const fullPath = join(postsDirectory, `${ slug }`);\n    const fileContents = fs.readFileSync(fullPath, 'utf8');\n    const {\n        data,\n        content,\n    } = matter(fileContents);\n\n    const obj = JSON.parse(JSON.stringify(data));\n    return {\n        id: dayjs(data.date).unix(),\n        fileName: realSlug,\n        url: `${ dayjs(data.date).format('YYYY/MM/DD') }/${ realSlug }`,\n        ...obj,\n        content,\n    } as Post;\n};\n\n// 列表目標資料夾中的所有markdown檔案，並且逐一取得markdown文件中的資料\nexport const getAllPosts: Function = (): Post[] => {\n    if ( posts.length === 0 ) {\n        const slugs = fs.readdirSync(postsDirectory);\n        posts = slugs.map((slug) => {\n            return getPost(slug);\n        });\n    }\n\n    return posts;\n};\n```\n\n## 文章列表\n\n有了這些，就可以把文章列表的部分印出來了！\n\n```typescript jsx\nexport const getStaticProps: GetStaticProps = async (context: GetStaticPropsContext<ParsedUrlQuery>): Promise<any> => {\n    const posts: Post[] = getAllPosts();\n    return {\n        props: {\n            posts: posts.slice(0, 10)\n        },\n    };\n};\n```\n\n## 文章內文\n\n接下來要讀取markdown中的內容，並且渲染出整個html，然後我也有針對markdwon的element做客制處理，例如`h1`的渲染就會如同下方的html\n\n```typescript jsx\nexport const h1 = (props: any) => {\n    const {children} = props;\n\n    return <div className={classNames(\"u-heading-v3\", \"g-mb-40\")}>\n        <h1 className={classNames(\"h1\", \"u-heading-v3__title\")}>\n            {children}\n        </h1>\n    </div>\n}\n```\n\n另外官方給的方式，渲染移植會有錯誤（如下圖），所以自己做了一個呈現的頁面，讓畫面可以有更完整的客製化功能\n\n![渲染錯誤](gatsbyjs-to-nextjs/render-error.png)\n\n```typescript jsx\nimport { NextPage } from 'next';\nimport ReactMarkdown from 'react-markdown';\n\nconst Posts: NextPage = (props: any) => {\n    return <>\n        <div className={ classNames('g-mb-30') }>\n             {/*略*/}\n            <ReactMarkdown components={ connponents }>{ props.content }</ReactMarkdown>\n        </div>\n        {/*略*/}\n    </>;\n};\n\nexport const getStaticProps: GetStaticProps = async ({ params }: any): Promise<any>  => {\n    const post = getPost(`${params.post[3]}.mdx`);\n    return {\n        props: {\n            ...post\n        },\n    };\n};\n\nexport const getStaticPaths: GetStaticPaths = async (): Promise<any>  => {\n    const posts = getAllPosts();\n    return {\n        paths: posts.map((post: Post) => {\n            return {\n                params: {\n                    post: post.url.split('/').map(i => i.toString()),\n                },\n            };\n        }),\n        fallback: false,\n    };\n};\n```\n\n## Tag標籤\n\n在Gatsby.js可以透過gql把文章標籤弄出來但在next.js中就只能自己處理了..\n\n我先在posts.ts中新加一個method，可以處理把文章的tag都列出來，然後在每一頁中添加印出tag的處理，這樣子就把原本Gatsby原有的功能做出來了！接下來差了分頁功能...\n\n```typescript\n// posts.ts\nexport const getTags: Function = (): { [index: string]: number } => {\n    const tags: { [index: string]: number } = {};\n    posts.forEach((post: Post) => {\n        post.tags.forEach((tag: string) => {\n            if ( tags[tag] === undefined ) {\n                tags[tag] = 1;\n            } else {\n                tags[tag]++;\n            }\n        });\n    });\n\n    return tags;\n};\n\n// pages/*\nexport const getStaticProps: GetStaticProps = async ({ params }: any): Promise<any>  => {\n    // 略\n    const allTags = getTags();\n    return {\n        props: {\n            // 略\n            allTags\n        },\n    };\n};\n```\n\n## 關於分頁功能\n\n每一頁只顯示10篇文章，所以在`index.tsx`先hard code 只取得文章前10筆，接下來再運用`getStaticPaths`的方式就可以達成分頁功能了！\n\n```typescript jsx\nindex.tsx中的getStaticProps\nexport const getStaticProps: GetStaticProps = async (context: GetStaticPropsContext<ParsedUrlQuery>): Promise<any> => {\n    const posts: Post[] = getAllPosts();\n    const allTags = getTags();\n    return {\n        props: {\n            posts: posts.slice(0, 10),\n            allTags,\n            total: posts.length\n        },\n    };\n};\n\n// [page].tsx\nexport const getStaticProps: GetStaticProps = async (context: GetStaticPropsContext<ParsedUrlQuery>): Promise<any> => {\n    const {\n        page,\n    }: any = context.params;\n\n    const posts: Post[] = getAllPosts();\n    const allTags = getTags();\n\n    const current = parseInt(page ?? '0');\n\n    return {\n        props: {\n            current,\n            posts: posts.slice((current - 1) * 10, current * 10),\n            allTags,\n            total: posts.length,\n        },\n    };\n};\n\nexport const getStaticPaths: GetStaticPaths = async (): Promise<any> => {\n    const pages = [];\n    const posts: Post[] = getAllPosts();\n\n    for (let i = 0; i < posts.length / 10; i++) {\n        pages.push({\n                       params: {\n                           page: `${ i + 1 }`,\n                       },\n                   });\n    }\n\n    return {\n        paths: pages,\n        fallback: false,\n    };\n};\n```\n\n## 參考連結\n\n[Next.js Migrate from Gatsby.js](https://nextjs.org/docs/migrating/from-gatsby)\n"},{"id":1617235200,"fileName":"select-number-tdd","url":"2021/04/01/select-number-tdd","title":"Select Number TDD練習","description":"之前同事去參加面試，在面試的時候有一道上機考的題目，我覺得很有趣並且是一個很好練習的一道題目，一開始我讓我們前端的新人試著寫出這道題， 沒想到所有新人都完成了，所以我想嘗試一下TDD的方式來撰寫這道題目。","date":"2021-04-01T00:00:00.000Z","tags":["tdd","react","jest"],"published":true,"content":"\n之前同事去參加面試，在面試的時候有一道上機考的題目，我覺得很有趣並且是一個很好練習的一道題目，一開始我讓我們前端的新人試著寫出這道題，\n沒想到所有新人都完成了，所以我想嘗試一下TDD的方式來撰寫這道題目。\n\n## 練習題目需求\n\n1. 每一區有1~10個數字，點擊後會變成選取狀態，再次點擊後取消選取\n1. 在畫面上共有4個區域，每個區域都有10個數字，每區選取的號碼不能重複選取(ex: 第一區選擇\"1\"則其他區數字\"1\"為不可選)\n1. 每一區都有一個重置按鈕，點擊後該區選取的數字要被清空，並且所有區可以選取胎數字\n\n## 事後檢討\n\n一開始我的commit是有循序漸進的但後面亂掉了，變成了一個commit有多個事件處理。\n第二個是在重構的時候沒有及時的重構，所以在後面開始出現了很多個重構的commit。\n\n[repo](https://github.com/Yi-Shiuan/select-numbers)\n"},{"id":1610409600,"fileName":"the-react-first-time","url":"2021/01/12/the-react-first-time","title":"React 入門的學習之路","description":"昨天面試一位React新手雖然最後因為一些原因沒有Hire她，但他問了一個問題讓我覺得很棒：可以有什麼方法可以讓我的能力加強嗎？ 在我第一次接觸React距今已經過了好久了，久到我已經忘記我是如何啟動第一個React的APP...但身為一個React開發者又是一位面試官的角色， 未來還會有更多學習React的新手不斷進入，我想好好分享一下在面試一個React的新人時我在乎哪些技能另外也能當作學習React的入門時一個學習路徑","date":"2021-01-12T00:00:00.000Z","tags":["react"],"published":true,"content":"\n昨天面試一位React新手雖然最後因為一些原因沒有Hire她，但他問了一個問題讓我覺得很棒：`可以有什麼方法可以讓我的能力加強嗎？`\n\n在我第一次接觸React距今已經過了好久了，久到我已經忘記我是如何啟動第一個React的APP...但身為一個React開發者又是一位面試官的角色，\n未來還會有更多學習React的新手不斷進入，我想好好分享一下在面試一個React的新人時我在乎哪些技能另外也能當作學習React的入門時一個學習路徑\n\n## Local state的應用\n\n在學習React的第一步，當然建議可以先從`npx create-react-app my-app`開始，當然第一步就是在畫面印出簡單的文字來當作一個進入點，\n在這之後建議可以開始做一個簡單的ToDo List的小專案，來體驗整個React的語法、JSX與Component等等的設計，Function Component與Class Component\n都要體驗一下。\n\n## Global state的使用\n\n在學會了React的local state的應用也做了一個簡單的todo list之後，我建議學習一下Redux或是其他Global state的套件來改寫一下剛才的todo list\n嘗試幾筆新增資料後，在畫面上驅動更新顯示出來\n\n在Global state我建議的是使用Redux與React Hook的Context兩種全域的狀態管理都要學習，畢竟未來進入職場的時候不知道會使用哪一個\n\n## Virtual DOM\n\n在學習Global state之後，當然建議好好惡補一下Virtual DOM這個東西，這對未來的職涯上有很大的幫助，但又偏偏許多人忽略這個東西的養成...\n\n## Fetch API\n\n當Global state上手後，建議練習一下在React的APP中呼叫一下api取得資料與送出資料的練習，畢竟在工作上有很大的概率出現的\n在呼叫API的部分我建議做兩個的練習，一個是使用fetch的方式另一個是axios的套件，然後了解一下這兩個的使用限制與優缺\n\n## Component 的設計\n\n在Global state後，嘗試一下把todo list的Component拆分成多個Component來練習，深入了解一下state與props的相異之處使用條件與限制，\n也把Global state的狀態應用在Component中，嘗試一下使用props與Global state來更新todo list的資料，然後觀察一下其中的差異與變化。\n\n## 生命週期\n\n最後我的建議是React的生命週期，觸發render的時機等等的這些生命週期，這會讓你在React的道路上可以少踩一些地雷或是少遇到一些錯誤。\n\n\n以上是我在近期面試許多React的新手與昨天面試的同學提問後，參與自身的學習經驗來給未來新入React的朋友簡單的一個路徑。\n當然學習路徑有很多但我面試時偏好也會問這類的問題，從中鑑別候選人對React的理解程度。\n\n###\n[建立全新的 React 應用程式](https://zh-hant.reactjs.org/docs/create-a-new-react-app.html)\n"},{"id":1609977600,"fileName":"best-practice-layout-in-nextjs","url":"2021/01/07/best-practice-layout-in-nextjs","title":"Next.js 的Layout最佳配置","description":"新專案即將完成之際，我們開始對各個頁面上的效能與一些過去被我們忽略的問題進行修正， 在這修正的過程中我發現了在每一次頁面切換時都會出現網站的Logo消失又再出現的問題， Logo是一個經常變動的圖片所以在專案中是透過GQL取得Logo的CDN位置後才做渲染的， 再深入排查後才發現原來過去我的觀念不是非常正確所以用這篇來筆記一下正確地處理做法，當作小抄避免未來再犯同樣的錯誤。","date":"2021-01-07T00:00:00.000Z","tags":["react","next.js","frontend","layout"],"published":true,"content":"\n## 前情提要\n\n新專案即將完成之際，我們開始對各個頁面上的效能與一些過去被我們忽略的問題進行修正，\n在這修正的過程中我發現了在每一次頁面切換時都會出現網站的Logo消失又再出現的問題，\nLogo是一個經常變動的圖片所以在專案中是透過GQL取得Logo的CDN位置後才做渲染的，\n再深入排查後才發現原來過去我的觀念不是非常正確所以用這篇來筆記一下正確地處理做法，當作小抄避免未來再犯同樣的錯誤。\n\n## Next.js Layout最佳配置\n\n在Next.js的Layout最佳配置應該是把Layout的component放在`_app.tsx`中，在轉換頁面時就不會再出現前情提要的相關問題了。\n\n```typescript jsx\nfunction App({Component, pageProps }: AppProps): any {\n\tconst apolloClient: any = useApollo(pageProps.initialApolloState);\n\n\treturn <ApolloProvider client={apolloClient}>\n\t\t    <Layout>\n\t\t\t    <Component {...pageProps} />\n\t\t\t</Layout>\n\t\t</ApolloProvider>\n}\n```\n\n```typescript jsx\nconst Index: NextPage<any> = (props: any): any => {\n\treturn <>\n            {/*index content*/}\n\t\t</>\n};\n```\n\n\n### 在得到結論前的一些排查點\n\n在一開始我們的`_app.tsx`與`index.tsx`或其他page都是這樣的設計，在Layout中有`Header`與`Footer`兩個component以及負責所有頁面上的版面配置，\n其中Header這個component中去取得GQL資料，但因為他是屬於React FunctionComponent的範疇，故無法使用getInitialProps這類的function\n\n```typescript jsx\nfunction App({Component, pageProps }: AppProps): any {\n\tconst apolloClient: any = useApollo(pageProps.initialApolloState);\n\n\treturn <ApolloProvider client={apolloClient}>\n\t\t\t<Component {...pageProps} />\n\t\t</ApolloProvider>\n}\n```\n\n```typescript jsx\nconst Index: NextPage<any> = (props: any): any => {\n\treturn <Layout>\n            {/*index content*/}\n\t\t</Layout>\n};\n```\n\n1. 在方案一的我是透過React Memo的方式Cache Layout起來下次使用Layout 這個component時就不會再重新渲染，但結果是仍然每次重新渲染Layout\n1. 在_app.tsx中取得相關的Layout配置所需要的圖檔與文字，透過props的方式傳入給Layout中並讓Header在Server side 渲染，\n但因為progress image的使用所以Logo仍然會有閃一下的情況\n\n然後在官網上看到了這麼一段....\n最後我把Layout放置到`_app.tsx`中，就可以如我們預期的一開始出現了progress image的Logo再出現真正的Logo，在每次轉頁時也沒有重新渲染相關的Layout component\n\n我想主要的幾個原因是，_app.tsx的執行時間以及在轉頁渲染的最小單位是整個Next page不是採用差異的方式重新渲染。\n\n> Next.js uses the App component to initialize pages. You can override it and control the page initialization. Which allows you to do amazing things like:\n>\n> - Persisting layout between page changes\n> - Keeping state when navigating pages\n> - Custom error handling using componentDidCatch\n> - Inject additional data into pages\n> - Add global CSS\n>\n> [Next.js Custom APP](https://nextjs.org/docs/advanced-features/custom-app)\n\n### 相關連結\n\n[Next.js Custom APP](https://nextjs.org/docs/advanced-features/custom-app)\n"}],"allTags":{"react":5,"next.js":3,"i18n":1,"gatsby.js":1,"postgresql":1,"database":2,"dotnet":1,"aws":4,"devops":7,"prevision":6,"iot":2,"platformio":2,"arduino":2,"esp":1,"elk":3,"azure":4,"vulnerability":1,"ssl":2,"vmss":1,"cd":3,"study4":1,"dotnetconf":1,"selenium":2,"tdd":1,"jest":1,"frontend":1,"layout":1,"ec2":1,"iac":1,"terraform":1,"ci":1,"jenkins":1,"ecs":1,"ansible":1,"redis":2,"protobuf":2,"serialize":2,"deserialize":2,"pub":1,"sub":1,"notify":1}},"__N_SSG":true}