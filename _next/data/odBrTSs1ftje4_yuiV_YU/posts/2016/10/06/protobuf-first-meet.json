{"pageProps":{"id":1475760616,"fileName":"protobuf-first-meet","url":"2016/10/06/protobuf-first-meet","title":"[ProtoBuf] 初次見面","description":"目前會採用ProtoBuf序列化是因為先前使用JSON有效能上的問題與在存取Redis上產生較高的延遲，所以改採用ProtoBuf來作為資料序列化與存放到Redis的主要格式。雖然在閱讀上需要自己寫小工具做轉譯，但在一般情況擁有較好的效能展現。","tags":["protobuf","serialize","deserialize"],"date":"2016-10-06T13:30:16.000Z","published":true,"content":"\n## 什麼是ProtoBuf？\n\n這是一個Google所開發出的資料儲存結構或物件（反）序列的結構（如 JOSN、XML、msgpack等），在官方網站的介紹上有這麼一段：\n> Protocol buffers are Google's language-neutral,\n> platform-neutral, extensible mechanism for serializing structured data\n> – think XML, but smaller, faster, and simpler.\n> You define how you want your data to be structured once,\n> then you can use special generated source code to easily write\n> and read your structured data to and from a variety of data streams and using a variety of languages.\n> <p style=\"text-align:right\"> from <a href=\"https://developers.google.com/protocol-buffers/\" target=\"_blank\">https://developers.google.com/protocol-buffers/</a></p>\n\nProtoBuf支援各種主流的語言(ex: C#, C++, JAVA等)，\n在官方中的[GitHub](https://github.com/google/protobuf)上有目前支援的語言實做，或是Third-party搜尋相關的實做套件。\n\n### ProtoBuf 優點\n\n* (反)序列**速度快**，方便於網路傳輸\n* 產出格式**內容小**，方便存放至檔案或其他Service\n\n### ProtoBuf 缺點\n\n* 二進位格式，難以閱讀\n* 使用上必須先作定義，需要先設定.proto檔案\n\n## 在 C# 中使用 ProtoBuf\n\n在專案中我是使用third-party的套件，[ProtoBuf-net](https://www.nuget.org/packages/protobuf-net)\n套件可以在nuget上找到，會選擇這個套件主要是因為在使用上較為簡便，也支援較多的設定的方式來做資料，設定的方式\n稍後會有比較詳細一些的介紹。\n\n### 定義方式\n\nProtoBuf-net設定的方式支援了以下三種方式\n\n#### Attribute\n\n這個方式，個人認為是一個較好的設定方式，\n\n```cs\n[ProtoContract]\npublic class TestClass\n{\n    [ProtoMember(1)]\n    public int TestA { get; set; }\n\n    [ProtoMember(2)]\n    public string TestB { get; set; }\n\n    [ProtoMember(3)]\n    public TestClassB TestC { get; set; }\n}\n\n[ProtoContract]\npublic class TestClassB\n{\n    ...\n}\n```\n\n這一個設定方式可以修改data model同時修改 Attribute 這樣在團隊使用上可以避免修改data model後\n也可馬上維護protobuf的設定，避免在runtime時因為設定上造成exception。\n\n#### .proto檔案\n\n這一個方式是官方的標準設定，這個需要額外產生一份.proto檔案，定義方式與格式可參考\n[官方網站](https://developers.google.com/protocol-buffers/docs/csharptutorial)\n的設定。\n\n這一個方式因為多產生了一個.proto的檔案，在修改data model後，必須要再額外修改.proto的檔案，\n有時候在開發上會有不一致的情況；在使用上與設定上也相對較為複雜。\n\n#### Runtime 定義\n\n這是在Application執行期間產生一份 RuntimeTypeModel，在Serializer的時候會以這一份RuntimeTypeModel為你的\ndata model做序列化，以下提供語法參考設定方式\n\n這一個方式會將原先定義覆蓋\n\n```cs\n    var metaType = RuntimeTypeModel.Default.Add(typeof(TestClassA), true);\n    metaType.AddSubType(100, typeof(TestA));\n\n    RuntimeTypeModel.Default.Add(typeof(TestA), false);\n```\n\n這一個會複寫(或新增)原先的定義\n```cs\n    var metaType = RuntimeTypeModel.Default;\n    var testA = metaType[typeof(TestClassA)];\n    testA.AddSubType(100, typeof(TestA));\n    metaType.Add(typeof(TestA), false);\n```\n\n## 總結\n\n目前會採用ProtoBuf序列化是因為先前使用JSON有效能上的問題與在存取Redis上產生較高的延遲，所以改採用\nProtoBuf來作為資料序列化與存放到Redis的主要格式。雖然在閱讀上需要自己寫小工具做轉譯，但在一般情況\n擁有較好的效能展現。\n\n\n其他更詳細的介紹可觀看\n[protobuf-net 官方GitHub](https://github.com/mgravell/protobuf-net#advanced-subjects)\n\n## 參考資料\n\n[Level up - protobuf-net - Serialize/DeSerialize data](http://larrynung.github.io/2016/08/23/protobuf-net-Serialize-DeSerialize-data/)\n\n[protobuf-net 官方GitHub](https://github.com/mgravell/protobuf-net)\n\n[Google protobuf](https://github.com/google/protobuf)\n"},"__N_SSG":true}