{"pageProps":{"posts":[{"id":1670630400,"fileName":"aws-dynamic-site-canary-deployment","url":"2022/12/10/aws-dynamic-site-canary-deployment","title":"非靜態網站使用AWS做金絲雀部署","description":"在佔新作改版時，我們會希望可以先讓一部分使用者先做測試而不是將使用者一次更新。在AWS透過ELB接收網路流量到後面的Container的流量設定該怎麼做呢？ 另外我們還希望可以做到如同AWS的新舊版本可以讓使用者自由的切換，這個該又如何處理這樣的需求呢？","date":"2022-12-10T00:00:00.000Z","tags":["aws","frontend","next.js"],"published":true,"content":"\n在佔新作改版時，我們會希望可以先讓一部分使用者先做測試而不是將使用者一次更新。在AWS透過ELB接收網路流量到後面的Container的流量設定該怎麼做呢？\n另外我們還希望可以做到如同AWS的新舊版本可以讓使用者自由的切換，這個該又如何處理這樣的需求呢？\n\n## 什麼是金絲雀部署？\n\n金絲雀部署的劉來是在礦工下礦坑時會先讓金絲雀飛進礦坑中，倘若金絲雀沒有了叫聲，表示礦坑底下的瓦斯濃度或是其他氣體濃度太高，礦工下礦坑就會有生命危險。\n金絲雀部署也有其他名稱如：礦工部署與灰度部署\n\n## 系統架構配置\n\n當使用者進入系統時，有90%的流量進入了`Old Version`中另外有10%的流量進入`New Version`中\n\n![AWS system architecture](aws-dynamic-site-canary-deployment/system-architecture.png)\n\n## Load balancer的設定\n\n在ELB中的設定呢分成兩個區塊，首先在主要的Rule設定上的`Forward to`中設定兩個target group，權重設定分配比例按照9:1的設定，Group-level stickiness要設定多久後要將重新做分配，就可以自動的建立金絲雀部署了\n\n![第一個TG設定](aws-dynamic-site-canary-deployment/main-tg-setting.png)\n\n但想要想可以自求的切換版本那只單純設定一條rule是不夠的！原因是因為Next.js的靜態檔案ex: js, css 靜態檔案的路徑是`_next/static/{BUILD_ID}`，所以要針對這樣的路徑多設定兩個不同的rule來做指向\n所以ELB的設定要多一個Path的條件，match了build id 才能導向該Container，這樣每次部署只要更新相對應的路徑就可以了！\n\n還需要再多一個設定，那就是切換舊版後需要一個條件讓使用者可以導向舊版的網站，所以這邊可以使用Query string或是Header的值來做判斷導向哪一個Target group中\n\n> 以前實作時，Next.js產生靜態檔案的路徑是`_next/{BUILD_ID}`\n"},{"id":1670198400,"fileName":"nextjs-i18n-with-react-intl","url":"2022/12/05/nextjs-i18n-with-react-intl","title":"Next.JS 靜態網站 + React-Intl 的 i18n","description":"多國語系在許多網站已經是不可或缺的一個功能，在自己的研究中想做這事件情很久了，在公司的日常開發中也有許多這樣的功能，但前人已經設定好了，沒有從頭來過的感覺 剛好這兩天終於有一個契機與必要實作的需求出現了。於是就把自己實作的步驟記錄下來！","date":"2022-12-05T00:00:00.000Z","tags":["react","next.js","i18n"],"published":true,"content":"\n多國語系在許多網站已經是不可或缺的一個功能，在自己的研究中想做這事件情很久了，在公司的日常開發中也有許多這樣的功能，但前人已經設定好了，沒有從頭來過的感覺\n剛好這兩天終於有一個契機與必要實作的需求出現了。於是就把自己實作的步驟記錄下來！\n\n### 1. 安裝React-intl\n\n```bash\nyarn add react-intl\n```\n\n### 2. 設定next.config.js\n\n開啟next.config.js設定預設的語系以及支援的語系設定，locales是設定支援的語系檔案而 defaultLocale 當沒有傳入語系設定時所使用的預設語系\n\n```js\nmodule.exports = {\n  ...\n  i18n: {\n    locales: ['en', 'tw'],\n    defaultLocale: 'tw',\n  },\n  ...\n};\n```\n\n### 3. 放置語系包的位置\n\n在語系設定上我的檔案會放在`/src/locales`中，裡面的檔案要對應到在**next.config.js**中所設定的語系相同，網站中有需要用到多國語系的語系檔案都可以在這邊設定\n\n語系的檔案結構\n```txt\n.\n├── ...\n├── src\n│   ├── locales\n│   │   ├── en.ts\n│   │   ├── tw.ts\n│   │   └── index.ts\n│   ├── pages\n│   │   ├── _app.ts\n│   └── ...\n└── ...\n```\n語系資料對應後續我們就可以使用`FormattedMessage`的Component來取得該資料值。\n```typescript\n// en.ts檔案設定\nexport const en = {\n    my_title: `Bruno's Jan Tech blogger`\n}\n\n// tw.ts\nexport const tw = {\n    my_title: `Bruno's 技術筆記`\n}\n\n// index.ts\nimport { en } from \"./en\";\nimport { tw } from \"./tw\";\n\nexport const messages: any = {\n    tw,\n    en\n}\n```\n\n### 4. 設定_app.tsx檔案\n\n在_app.tsx中設定`IntlProvider`以及語系包的資料設定\n\n```tsx\nimport { AppProps } from 'next/app';\nimport { useRouter } from 'next/router';\nimport React, { ReactElement } from 'react';\nimport { IntlProvider } from 'react-intl';\nimport { messages } from '~/locales';\n\nconst App: any = ({\n                      Component,\n                      pageProps,\n                  }: AppProps) => {\n    const router = useRouter();\n    const {\n        locale,\n        defaultLocale,\n    } = router;\n    const message: any = messages[locale];\n    return <IntlProvider locale={ locale } defaultLocale={ 'tw' } messages={ message }>\n        <Component { ...pageProps } />\n    </IntlProvider>;\n};\n\nexport default App;\n```\n\n接下來就可以在畫面上需要多語言翻譯的位置加上下列程式碼就可以展現多國語系了！\n```tsx\nimport { FormattedMessage } from 'react-intl';\n\n\n<FormattedMessage id='my_title' defaultMessage='My default title' />\n```\n\n### 輸出靜態網站\n\n完成了多語系社的設定以後，當要輸出靜態網站時出現了錯誤...竟然說i18n不支援`next export`！\n\n```bash\n$ next export\ninfo  - using build directory: /Users/Yi-Shiuan/Documents/git/Blogger/.next\ninfo  - Copying \"static build\" directory\ninfo  - No \"exportPathMap\" found in \"/Users/Yi-Shiuan/Documents/git/Blogger/next.config.js\". Generating map from \"./pages\"\nError: i18n support is not compatible with next export. See here for more info on deploying: https://nextjs.org/docs/deployment\n    at /Users/Yi-Shiuan/Documents/git/Blogger/node_modules/next/dist/export/index.js:147:19\n    at async Span.traceAsyncFn (/Users/Yi-Shiuan/Documents/git/Blogger/node_modules/next/dist/trace/trace.js:79:20)\nerror Command failed with exit code 1.\ninfo Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\nerror Command failed with exit code 1.\ninfo Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\n```\n\n後來在官網中找到了這一段文字..\n\n> Note that Internationalized Routing does not integrate with next export as next export does not leverage the Next.js routing layer.\n> Hybrid Next.js applications that do not use next export are fully supported.\n>\n> [Next.js - Internationalized Routing](https://nextjs.org/docs/advanced-features/i18n-routing#limits-for-the-i18n-config)\n\n好吧，看起來我想輸出靜態網站不支援這樣的設定，所以只好動點手腳讓系統支援他！\n\n用靜態路由的設定來讓他可以支援多國語系\n\n```tsx\nexport const getStaticPaths: GetStaticPaths = async (): Promise<any> => {\n    return {\n        paths: [\n            { params: { lang: 'tw' } },\n            { params: { lang: 'en' } },\n        ],\n        fallback: false,\n    };\n};\n```\n再次修改_app.tsx\n\n使用路由取得語系，再去設定 `IntlProvider`載入的語系設定\n```tsx\nimport { AppProps } from 'next/app';\nimport { useRouter } from 'next/router';\nimport React, { ReactElement } from 'react';\nimport { IntlProvider } from 'react-intl';\nimport { messages } from '~/locales';\n\nconst App: any = ({\n                      Component,\n                      pageProps,\n                  }: AppProps) => {\n    library.add(fas, fab);\n    const router = useRouter();\n    const {\n        locale,\n        defaultLocale,\n    } = router;\n    const { lang } = router.query;\n    // @ts-ignore\n    const message: any = messages[lang ?? 'tw'];\n\n    return <IntlProvider locale={ locale ?? 'tw' } defaultLocale={ 'tw' } messages={ message }>\n        <Component { ...pageProps } />\n    </IntlProvider>;\n};\n\nexport default App;\n```\n\n最後移除next.config.js中的設定\n```js\n    i18n: {\n        locales: ['en', 'tw'],\n        defaultLocale: 'tw',\n    },\n```\n\n這樣就可以在靜態網站中擁有多國語系囉！\n\n### 參考資料\n\n[Next.js - Internationalized Routing](https://nextjs.org/docs/advanced-features/i18n-routing#limits-for-the-i18n-config)\n\n[Internationalizing Next.js app with react-intl by Iskren Lalov](https://www.laloov.com/posts/internationalizing-next-js-app-with-react-intl)\n"},{"id":1666224000,"fileName":"gatsbyjs-to-nextjs","url":"2022/10/20/gatsbyjs-to-nextjs","title":"從Gatsby.js轉換到Next.js","description":"紀錄從Gatsby.js轉換到了Next.js的踩地雷過程","date":"2022-10-20T00:00:00.000Z","tags":["react","gatsby.js","next.js"],"published":true,"content":"\n其實Gatsby.js並沒有什麼不好，只是他每一次改版都需要花費許多精力去做更新，我從1.0用到了3.0，最後4.0真的讓我痛下決心轉換到了Next.js的懷抱\n\n雖然官方有介紹如何從Gatsby.js遷移到Next.js的範例，但說真的還有許多沒有寫清楚的地方這邊先做幾個紀錄\n\n## 更新package.json\n\n除離移除所有的Gatsby.js的套件外，還需要安裝幾個套件這幾個套件官方都有說明主要是為了渲染markdown的文件以及讀取markdown的文件的套件功能\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"next build\",\n    \"export\": \"next export\",\n    \"dev\": \"next dev\",\n    \"start\": \"next start\"\n  },\n  \"subpath\": \"`/*\",\n  \"dependencies\": {\n    \"gray-matter\": \"^4.0.3\",\n    \"next\": \"^12.3.1\",\n    \"react-markdown\": \"^8.0.3\",\n    \"react-syntax-highlighter\": \"^15.4.4\",\n    \"remark\": \"^14.0.2\",\n    \"remark-html\": \"^15.0.1\"\n  }\n}\n```\n\n## 讀取markdown檔案\n\n在部落格中的markdown文件資料夾是這樣放的 `src/posts/{post}.mdx`\n\n```typescript\n// posts.ts\n\nimport dayjs from 'dayjs';\nimport fs from 'fs';\nimport matter from 'gray-matter';\nimport { join } from 'path';\n\nexport type Post = {\n    id: number;\n    fileName: string;\n    url: string;\n    title: string;\n    tags: string[];\n    content: string;\n    date: Date;\n    publish: boolean;\n    description: string;\n}\n\nconst postsDirectory = join(process.cwd(), '<<markdown 檔案位置>>');\nlet posts: Post[] = [];\n\n// 取得markdown文件中的內容\nexport const getPost: Function = (slug: string): Post => {\n    const realSlug = slug.replace(/\\.mdx$/, '');\n    const fullPath = join(postsDirectory, `${ slug }`);\n    const fileContents = fs.readFileSync(fullPath, 'utf8');\n    const {\n        data,\n        content,\n    } = matter(fileContents);\n\n    const obj = JSON.parse(JSON.stringify(data));\n    return {\n        id: dayjs(data.date).unix(),\n        fileName: realSlug,\n        url: `${ dayjs(data.date).format('YYYY/MM/DD') }/${ realSlug }`,\n        ...obj,\n        content,\n    } as Post;\n};\n\n// 列表目標資料夾中的所有markdown檔案，並且逐一取得markdown文件中的資料\nexport const getAllPosts: Function = (): Post[] => {\n    if ( posts.length === 0 ) {\n        const slugs = fs.readdirSync(postsDirectory);\n        posts = slugs.map((slug) => {\n            return getPost(slug);\n        });\n    }\n\n    return posts;\n};\n```\n\n## 文章列表\n\n有了這些，就可以把文章列表的部分印出來了！\n\n```typescript jsx\nexport const getStaticProps: GetStaticProps = async (context: GetStaticPropsContext<ParsedUrlQuery>): Promise<any> => {\n    const posts: Post[] = getAllPosts();\n    return {\n        props: {\n            posts: posts.slice(0, 10)\n        },\n    };\n};\n```\n\n## 文章內文\n\n接下來要讀取markdown中的內容，並且渲染出整個html，然後我也有針對markdwon的element做客制處理，例如`h1`的渲染就會如同下方的html\n\n```typescript jsx\nexport const h1 = (props: any) => {\n    const {children} = props;\n\n    return <div className={classNames(\"u-heading-v3\", \"g-mb-40\")}>\n        <h1 className={classNames(\"h1\", \"u-heading-v3__title\")}>\n            {children}\n        </h1>\n    </div>\n}\n```\n\n另外官方給的方式，渲染移植會有錯誤（如下圖），所以自己做了一個呈現的頁面，讓畫面可以有更完整的客製化功能\n\n![渲染錯誤](gatsbyjs-to-nextjs/render-error.png)\n\n```typescript jsx\nimport { NextPage } from 'next';\nimport ReactMarkdown from 'react-markdown';\n\nconst Posts: NextPage = (props: any) => {\n    return <>\n        <div className={ classNames('g-mb-30') }>\n             {/*略*/}\n            <ReactMarkdown components={ connponents }>{ props.content }</ReactMarkdown>\n        </div>\n        {/*略*/}\n    </>;\n};\n\nexport const getStaticProps: GetStaticProps = async ({ params }: any): Promise<any>  => {\n    const post = getPost(`${params.post[3]}.mdx`);\n    return {\n        props: {\n            ...post\n        },\n    };\n};\n\nexport const getStaticPaths: GetStaticPaths = async (): Promise<any>  => {\n    const posts = getAllPosts();\n    return {\n        paths: posts.map((post: Post) => {\n            return {\n                params: {\n                    post: post.url.split('/').map(i => i.toString()),\n                },\n            };\n        }),\n        fallback: false,\n    };\n};\n```\n\n## Tag標籤\n\n在Gatsby.js可以透過gql把文章標籤弄出來但在next.js中就只能自己處理了..\n\n我先在posts.ts中新加一個method，可以處理把文章的tag都列出來，然後在每一頁中添加印出tag的處理，這樣子就把原本Gatsby原有的功能做出來了！接下來差了分頁功能...\n\n```typescript\n// posts.ts\nexport const getTags: Function = (): { [index: string]: number } => {\n    const tags: { [index: string]: number } = {};\n    posts.forEach((post: Post) => {\n        post.tags.forEach((tag: string) => {\n            if ( tags[tag] === undefined ) {\n                tags[tag] = 1;\n            } else {\n                tags[tag]++;\n            }\n        });\n    });\n\n    return tags;\n};\n\n// pages/*\nexport const getStaticProps: GetStaticProps = async ({ params }: any): Promise<any>  => {\n    // 略\n    const allTags = getTags();\n    return {\n        props: {\n            // 略\n            allTags\n        },\n    };\n};\n```\n\n## 關於分頁功能\n\n每一頁只顯示10篇文章，所以在`index.tsx`先hard code 只取得文章前10筆，接下來再運用`getStaticPaths`的方式就可以達成分頁功能了！\n\n```typescript jsx\nindex.tsx中的getStaticProps\nexport const getStaticProps: GetStaticProps = async (context: GetStaticPropsContext<ParsedUrlQuery>): Promise<any> => {\n    const posts: Post[] = getAllPosts();\n    const allTags = getTags();\n    return {\n        props: {\n            posts: posts.slice(0, 10),\n            allTags,\n            total: posts.length\n        },\n    };\n};\n\n// [page].tsx\nexport const getStaticProps: GetStaticProps = async (context: GetStaticPropsContext<ParsedUrlQuery>): Promise<any> => {\n    const {\n        page,\n    }: any = context.params;\n\n    const posts: Post[] = getAllPosts();\n    const allTags = getTags();\n\n    const current = parseInt(page ?? '0');\n\n    return {\n        props: {\n            current,\n            posts: posts.slice((current - 1) * 10, current * 10),\n            allTags,\n            total: posts.length,\n        },\n    };\n};\n\nexport const getStaticPaths: GetStaticPaths = async (): Promise<any> => {\n    const pages = [];\n    const posts: Post[] = getAllPosts();\n\n    for (let i = 0; i < posts.length / 10; i++) {\n        pages.push({\n                       params: {\n                           page: `${ i + 1 }`,\n                       },\n                   });\n    }\n\n    return {\n        paths: pages,\n        fallback: false,\n    };\n};\n```\n\n## 參考連結\n\n[Next.js Migrate from Gatsby.js](https://nextjs.org/docs/migrating/from-gatsby)\n"},{"id":1609977600,"fileName":"best-practice-layout-in-nextjs","url":"2021/01/07/best-practice-layout-in-nextjs","title":"Next.js 的Layout最佳配置","description":"新專案即將完成之際，我們開始對各個頁面上的效能與一些過去被我們忽略的問題進行修正， 在這修正的過程中我發現了在每一次頁面切換時都會出現網站的Logo消失又再出現的問題， Logo是一個經常變動的圖片所以在專案中是透過GQL取得Logo的CDN位置後才做渲染的， 再深入排查後才發現原來過去我的觀念不是非常正確所以用這篇來筆記一下正確地處理做法，當作小抄避免未來再犯同樣的錯誤。","date":"2021-01-07T00:00:00.000Z","tags":["react","next.js","frontend","layout"],"published":true,"content":"\n## 前情提要\n\n新專案即將完成之際，我們開始對各個頁面上的效能與一些過去被我們忽略的問題進行修正，\n在這修正的過程中我發現了在每一次頁面切換時都會出現網站的Logo消失又再出現的問題，\nLogo是一個經常變動的圖片所以在專案中是透過GQL取得Logo的CDN位置後才做渲染的，\n再深入排查後才發現原來過去我的觀念不是非常正確所以用這篇來筆記一下正確地處理做法，當作小抄避免未來再犯同樣的錯誤。\n\n## Next.js Layout最佳配置\n\n在Next.js的Layout最佳配置應該是把Layout的component放在`_app.tsx`中，在轉換頁面時就不會再出現前情提要的相關問題了。\n\n```typescript jsx\nfunction App({Component, pageProps }: AppProps): any {\n\tconst apolloClient: any = useApollo(pageProps.initialApolloState);\n\n\treturn <ApolloProvider client={apolloClient}>\n\t\t    <Layout>\n\t\t\t    <Component {...pageProps} />\n\t\t\t</Layout>\n\t\t</ApolloProvider>\n}\n```\n\n```typescript jsx\nconst Index: NextPage<any> = (props: any): any => {\n\treturn <>\n            {/*index content*/}\n\t\t</>\n};\n```\n\n\n### 在得到結論前的一些排查點\n\n在一開始我們的`_app.tsx`與`index.tsx`或其他page都是這樣的設計，在Layout中有`Header`與`Footer`兩個component以及負責所有頁面上的版面配置，\n其中Header這個component中去取得GQL資料，但因為他是屬於React FunctionComponent的範疇，故無法使用getInitialProps這類的function\n\n```typescript jsx\nfunction App({Component, pageProps }: AppProps): any {\n\tconst apolloClient: any = useApollo(pageProps.initialApolloState);\n\n\treturn <ApolloProvider client={apolloClient}>\n\t\t\t<Component {...pageProps} />\n\t\t</ApolloProvider>\n}\n```\n\n```typescript jsx\nconst Index: NextPage<any> = (props: any): any => {\n\treturn <Layout>\n            {/*index content*/}\n\t\t</Layout>\n};\n```\n\n1. 在方案一的我是透過React Memo的方式Cache Layout起來下次使用Layout 這個component時就不會再重新渲染，但結果是仍然每次重新渲染Layout\n1. 在_app.tsx中取得相關的Layout配置所需要的圖檔與文字，透過props的方式傳入給Layout中並讓Header在Server side 渲染，\n但因為progress image的使用所以Logo仍然會有閃一下的情況\n\n然後在官網上看到了這麼一段....\n最後我把Layout放置到`_app.tsx`中，就可以如我們預期的一開始出現了progress image的Logo再出現真正的Logo，在每次轉頁時也沒有重新渲染相關的Layout component\n\n我想主要的幾個原因是，_app.tsx的執行時間以及在轉頁渲染的最小單位是整個Next page不是採用差異的方式重新渲染。\n\n> Next.js uses the App component to initialize pages. You can override it and control the page initialization. Which allows you to do amazing things like:\n>\n> - Persisting layout between page changes\n> - Keeping state when navigating pages\n> - Custom error handling using componentDidCatch\n> - Inject additional data into pages\n> - Add global CSS\n>\n> [Next.js Custom APP](https://nextjs.org/docs/advanced-features/custom-app)\n\n### 相關連結\n\n[Next.js Custom APP](https://nextjs.org/docs/advanced-features/custom-app)\n"}],"allTags":{"git":1,"vue":1,"nuxt":1,"vite":1,"devops":8,"study4":2,"dotnetconf":2,"aws":5,"frontend":2,"next.js":4,"react":5,"i18n":1,"gatsby.js":1,"postgresql":1,"database":2,"dotnet":1,"prevision":6,"iot":2,"platformio":2,"arduino":2,"esp":1,"elk":3,"azure":4,"vulnerability":1,"ssl":2,"vmss":1,"cd":3,"selenium":2,"tdd":1,"jest":1,"layout":1,"ec2":1,"iac":1,"terraform":1,"ci":1,"jenkins":1,"ecs":1,"ansible":1,"redis":2,"protobuf":2,"serialize":2,"deserialize":2,"pub":1,"sub":1,"notify":1}},"__N_SSG":true}