<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.24.47"/><title data-react-helmet="true"></title><link as="script" rel="preload" href="/webpack-runtime-52020a934140e66e2c83.js"/><link as="script" rel="preload" href="/framework-5e713f507919262c2771.js"/><link as="script" rel="preload" href="/app-11fed37aabd59ecf64dd.js"/><link as="script" rel="preload" href="/component---src-posts-protobuf-serialize-and-deserialize-protobuf-serialize-and-deserialize-mdx-5af0f1f68a59fd825eb0.js"/><link as="fetch" rel="preload" href="/page-data/protobuf-serialize-and-deserialize/protobuf-serialize-and-deserialize/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><h1>ProtoBuf</h1><p>這一篇應該是我ProtoBuf的系列文章第二篇，上一篇只簡單說了一些安裝方式與一些定義檔
的設定根本就不知道該如何使用這一個好用的序列化工具。依樣會是使用protobuf-net
這一個套件來做一個簡單的紀錄。</p><h2>ProtoBuf 序列化</h2><p>在使用 ProtoBuf 的第一步就必須了解 Stream 的資料格式，因為在(反)序列化
的過程中，預設都是使用 Stream 作為媒介。序列化的部份是使用 Serializer.Serialize
這個方法來處理。</p><h3>Simple Code 1 - 序列化</h3><pre><code class="language-cs">public void SerializeToStream&lt;T&gt;(T data, Stream stream)
{
    Serializer.Serialize(stream, data)
}

public void Main()
{
    using (var stream = new MemoryStream())
    {
        this.SerializeToStream&lt;object&gt;(data, stream);
    }
}
</code></pre><p>主要原因是若Stream關閉後就無法做任何的操作，所以交由外部來控制Stream的資源初始與回收。
可以在序列化成為 Array 或 String 的格式。</p><h3>Simple Code 2 - Serialize to byte array and string</h3><pre><code class="language-cs">public byte[] SerializeToBytes&lt;T&gt;(T data)
{
    byte[] result;
    using (var stream = new MemoryStream())
    {
        this.SerializeToStream(data, stream);
        result = stream.ToArray();
    }

    return result;
}

public string SerializeToString&lt;T&gt;(T data)
{
    string result;
    using (var stream = new MemoryStream())
    {
        this.SerializeToStream(data, stream);
        result = Encoding.ASCII.GetString(stream.ToArray());
    }

    return result;
}
</code></pre><p>在Format 成 String 我是採用ASCII的編碼方式，讓他出來會像16進位的感覺。</p><blockquote><p>也可以使用 Convert.ToBase64String(stream.ToArray()); 產生文字資料</p></blockquote><h2>ProtoBuf 反序列化</h2><p>在反序列化的部分也是預設採用 Stream 的資料格式來處理，</p><h3>Simple Code 3 - 反序列化</h3><pre><code class="language-cs">public T SerializeToStream&lt;T&gt;(Stream stream)
{
    return Serializer.Deserialize&lt;T&gt;(stream, data)
}
</code></pre><h3>Simple Code 4 - 針對 Byte array and string deserialize</h3><pre><code class="language-cs">public T DeSerializeFromBytes&lt;T&gt;(byte[] data)
{
    T result;
    using (var stream = new MemoryStream(data))
    {
        stream.Seek(0, SeekOrigin.Begin);
        result = this.DeSerializeFromStream&lt;T&gt;(stream);
    }

    return result;
}

public T DeSerializeFromString&lt;T&gt;(string data)
{
    return this.DeSerializeFromBytes&lt;T&gt;(Encoding.ASCII.GetBytes(data));
}
</code></pre><blockquote><p>注： 若string是使用base64字元輸出，那麼在deserialize時就必須使用
Convert.FromBase64String(data) 處理</p></blockquote></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/protobuf-serialize-and-deserialize/protobuf-serialize-and-deserialize/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-c9efa5a654d0f0cead8a.js"],"app":["/app-11fed37aabd59ecf64dd.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-2953f7492475c79b5fbd.js"],"component---src-pages-friends-tsx":["/component---src-pages-friends-tsx-4747d5e1c77ca9dca6dd.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-8c30cce20661b19bb649.js"],"component---src-pages-posts-tsx":["/component---src-pages-posts-tsx-57deeaa08b7a8d97f140.js"],"component---src-pages-tags-tsx":["/component---src-pages-tags-tsx-3a34a140c58edc1cbb90.js"],"component---src-posts-ecs-deploy-preparing-ecs-deploy-preparing-mdx":["/component---src-posts-ecs-deploy-preparing-ecs-deploy-preparing-mdx-d244aea1d8f01cdafaa4.js"],"component---src-posts-protobuf-first-meet-protobuf-first-meet-mdx":["/component---src-posts-protobuf-first-meet-protobuf-first-meet-mdx-17717a200e001c9bb4b9.js"],"component---src-posts-protobuf-serialize-and-deserialize-protobuf-serialize-and-deserialize-mdx":["/component---src-posts-protobuf-serialize-and-deserialize-protobuf-serialize-and-deserialize-mdx-5af0f1f68a59fd825eb0.js"],"component---src-posts-redis-data-types-redis-data-types-mdx":["/component---src-posts-redis-data-types-redis-data-types-mdx-669d063d325f291c54be.js"],"component---src-posts-redis-pub-sub-application-notification-redis-pub-sub-application-notification-mdx":["/component---src-posts-redis-pub-sub-application-notification-redis-pub-sub-application-notification-mdx-567a010f19d29807e048.js"]};/*]]>*/</script><script src="/polyfill-c9efa5a654d0f0cead8a.js" nomodule=""></script><script src="/component---src-posts-protobuf-serialize-and-deserialize-protobuf-serialize-and-deserialize-mdx-5af0f1f68a59fd825eb0.js" async=""></script><script src="/app-11fed37aabd59ecf64dd.js" async=""></script><script src="/framework-5e713f507919262c2771.js" async=""></script><script src="/webpack-runtime-52020a934140e66e2c83.js" async=""></script></body></html>