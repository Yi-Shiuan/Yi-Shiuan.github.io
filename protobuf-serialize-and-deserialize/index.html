<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.24.53"/><title data-react-helmet="true"></title><link as="script" rel="preload" href="/webpack-runtime-544405c35a3b28f36a85.js"/><link as="script" rel="preload" href="/framework-fca5a6c89ebf46562859.js"/><link as="script" rel="preload" href="/app-f589e3d21a655d33fe88.js"/><link as="script" rel="preload" href="/component---src-posts-protobuf-serialize-and-deserialize-index-mdx-798851ade757f2ab6db2.js"/><link as="fetch" rel="preload" href="/page-data/protobuf-serialize-and-deserialize/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><h1>ProtoBuf</h1><p>這一篇應該是我ProtoBuf的系列文章第二篇，上一篇只簡單說了一些安裝方式與一些定義檔
的設定根本就不知道該如何使用這一個好用的序列化工具。依樣會是使用protobuf-net
這一個套件來做一個簡單的紀錄。</p><h2>ProtoBuf 序列化</h2><p>在使用 ProtoBuf 的第一步就必須了解 Stream 的資料格式，因為在(反)序列化
的過程中，預設都是使用 Stream 作為媒介。序列化的部份是使用 Serializer.Serialize
這個方法來處理。</p><h3>Simple Code 1 - 序列化</h3><pre><code class="language-cs">public void SerializeToStream&lt;T&gt;(T data, Stream stream)
{
    Serializer.Serialize(stream, data)
}

public void Main()
{
    using (var stream = new MemoryStream())
    {
        this.SerializeToStream&lt;object&gt;(data, stream);
    }
}
</code></pre><p>主要原因是若Stream關閉後就無法做任何的操作，所以交由外部來控制Stream的資源初始與回收。
可以在序列化成為 Array 或 String 的格式。</p><h3>Simple Code 2 - Serialize to byte array and string</h3><pre><code class="language-cs">public byte[] SerializeToBytes&lt;T&gt;(T data)
{
    byte[] result;
    using (var stream = new MemoryStream())
    {
        this.SerializeToStream(data, stream);
        result = stream.ToArray();
    }

    return result;
}

public string SerializeToString&lt;T&gt;(T data)
{
    string result;
    using (var stream = new MemoryStream())
    {
        this.SerializeToStream(data, stream);
        result = Encoding.ASCII.GetString(stream.ToArray());
    }

    return result;
}
</code></pre><p>在Format 成 String 我是採用ASCII的編碼方式，讓他出來會像16進位的感覺。</p><blockquote><p>也可以使用 Convert.ToBase64String(stream.ToArray()); 產生文字資料</p></blockquote><h2>ProtoBuf 反序列化</h2><p>在反序列化的部分也是預設採用 Stream 的資料格式來處理，</p><h3>Simple Code 3 - 反序列化</h3><pre><code class="language-cs">public T SerializeToStream&lt;T&gt;(Stream stream)
{
    return Serializer.Deserialize&lt;T&gt;(stream, data)
}
</code></pre><h3>Simple Code 4 - 針對 Byte array and string deserialize</h3><pre><code class="language-cs">public T DeSerializeFromBytes&lt;T&gt;(byte[] data)
{
    T result;
    using (var stream = new MemoryStream(data))
    {
        stream.Seek(0, SeekOrigin.Begin);
        result = this.DeSerializeFromStream&lt;T&gt;(stream);
    }

    return result;
}

public T DeSerializeFromString&lt;T&gt;(string data)
{
    return this.DeSerializeFromBytes&lt;T&gt;(Encoding.ASCII.GetBytes(data));
}
</code></pre><blockquote><p>注： 若string是使用base64字元輸出，那麼在deserialize時就必須使用
Convert.FromBase64String(data) 處理</p></blockquote></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/protobuf-serialize-and-deserialize/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-5174109e5e45abad2cd8.js"],"app":["/app-f589e3d21a655d33fe88.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-e5c6ea8e84e61f75514d.js"],"component---src-pages-about-tsx":["/component---src-pages-about-tsx-c5e7b4947c16607c77ef.js"],"component---src-pages-friends-tsx":["/component---src-pages-friends-tsx-3dd78a20f486f0d1c369.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-a37da26840c525702480.js"],"component---src-pages-posts-tsx":["/component---src-pages-posts-tsx-fc80ff6a05ee2649f711.js"],"component---src-pages-tags-tsx":["/component---src-pages-tags-tsx-a26309a6e3e819ae2d36.js"],"component---src-posts-ecs-deploy-preparing-index-mdx":["/component---src-posts-ecs-deploy-preparing-index-mdx-bfddfa1977bb819ae5c6.js"],"component---src-posts-jenkins-selenium-grid-index-mdx":["/component---src-posts-jenkins-selenium-grid-index-mdx-ffba532a3c2792455388.js"],"component---src-posts-protobuf-first-meet-index-mdx":["/component---src-posts-protobuf-first-meet-index-mdx-8dfb691d66e383c0fac0.js"],"component---src-posts-protobuf-serialize-and-deserialize-index-mdx":["/component---src-posts-protobuf-serialize-and-deserialize-index-mdx-798851ade757f2ab6db2.js"],"component---src-posts-redis-data-types-index-mdx":["/component---src-posts-redis-data-types-index-mdx-5c8ff9a3e4738dc6e191.js"],"component---src-posts-redis-pub-sub-application-notification-index-mdx":["/component---src-posts-redis-pub-sub-application-notification-index-mdx-a2d63d15ba9fab44ab3c.js"]};/*]]>*/</script><script src="/polyfill-5174109e5e45abad2cd8.js" nomodule=""></script><script src="/component---src-posts-protobuf-serialize-and-deserialize-index-mdx-798851ade757f2ab6db2.js" async=""></script><script src="/app-f589e3d21a655d33fe88.js" async=""></script><script src="/framework-fca5a6c89ebf46562859.js" async=""></script><script src="/webpack-runtime-544405c35a3b28f36a85.js" async=""></script></body></html>