<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>饅頭小舖</title>
  
  <subtitle>科技饅頭的開發筆記本</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yi-shiuan.github.io/"/>
  <updated>2018-01-03T03:26:48.914Z</updated>
  <id>http://yi-shiuan.github.io/</id>
  
  <author>
    <name>Yi-Shiuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[ProtoBuf] ProtoBuf Serialize 與 DeSerialize！</title>
    <link href="http://yi-shiuan.github.io/2016/10/07/%5BProtoBuf%5D%20ProtoBuf%20Serialize%20%E8%88%87%20DeSerialize%EF%BC%81/"/>
    <id>http://yi-shiuan.github.io/2016/10/07/[ProtoBuf] ProtoBuf Serialize 與 DeSerialize！/</id>
    <published>2016-10-07T14:44:15.000Z</published>
    <updated>2018-01-03T03:26:48.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ProtoBuf"><a href="#ProtoBuf" class="headerlink" title="ProtoBuf"></a>ProtoBuf</h1><p>這一篇應該是我ProtoBuf的系列文章第二篇，上一篇只簡單說了一些安裝方式與一些定義檔<br>的設定根本就不知道該如何使用這一個好用的序列化工具。依樣會是使用protobuf-net<br>這一個套件來做一個簡單的紀錄。</p><h2 id="ProtoBuf-序列化"><a href="#ProtoBuf-序列化" class="headerlink" title="ProtoBuf 序列化"></a>ProtoBuf 序列化</h2><p>在使用 ProtoBuf 的第一步就必須了解 Stream 的資料格式，因為在(反)序列化<br>的過程中，預設都是使用 Stream 作為媒介。序列化的部份是使用 Serializer.Serialize<br>這個方法來處理。</p><h3 id="Simple-Code-1-序列化"><a href="#Simple-Code-1-序列化" class="headerlink" title="Simple Code 1 - 序列化"></a>Simple Code 1 - 序列化</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> SerializeToStream&lt;T&gt;(T data, Stream stream)</span><br><span class="line">&#123;</span><br><span class="line">    Serializer.Serialize(stream, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.SerializeToStream&lt;<span class="keyword">object</span>&gt;(data, stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要原因是若Stream關閉後就無法做任何的操作，所以交由外部來控制Stream的資源初始與回收。<br>可以在序列化成為 Array 或 String 的格式。</p><h3 id="Simple-Code-2-Serialize-to-byte-array-and-string"><a href="#Simple-Code-2-Serialize-to-byte-array-and-string" class="headerlink" title="Simple Code 2 - Serialize to byte array and string"></a>Simple Code 2 - Serialize to byte array and string</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] SerializeToBytes&lt;T&gt;(T data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] result;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.SerializeToStream(data, stream);</span><br><span class="line">        result = stream.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> SerializeToString&lt;T&gt;(T data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">string</span> result;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.SerializeToStream(data, stream);</span><br><span class="line">        result = Encoding.ASCII.GetString(stream.ToArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Format 成 String 我是採用ASCII的編碼方式，讓他出來會像16進位的感覺。</p><blockquote><p>也可以使用 Convert.ToBase64String(stream.ToArray()); 產生文字資料</p></blockquote><h2 id="ProtoBuf-反序列化"><a href="#ProtoBuf-反序列化" class="headerlink" title="ProtoBuf 反序列化"></a>ProtoBuf 反序列化</h2><p>在反序列化的部分也是預設採用 Stream 的資料格式來處理，</p><h3 id="Simple-Code-3-反序列化"><a href="#Simple-Code-3-反序列化" class="headerlink" title="Simple Code 3 - 反序列化"></a>Simple Code 3 - 反序列化</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T SerializeToStream&lt;T&gt;(Stream stream)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Serializer.Deserialize&lt;T&gt;(stream, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Simple-Code-4-針對-Byte-array-and-string-deserialize"><a href="#Simple-Code-4-針對-Byte-array-and-string-deserialize" class="headerlink" title="Simple Code 4 - 針對 Byte array and string deserialize"></a>Simple Code 4 - 針對 Byte array and string deserialize</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T DeSerializeFromBytes&lt;T&gt;(<span class="keyword">byte</span>[] data)</span><br><span class="line">&#123;</span><br><span class="line">    T result;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> MemoryStream(data))</span><br><span class="line">    &#123;</span><br><span class="line">        stream.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">        result = <span class="keyword">this</span>.DeSerializeFromStream&lt;T&gt;(stream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T DeSerializeFromString&lt;T&gt;(<span class="keyword">string</span> data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.DeSerializeFromBytes&lt;T&gt;(Encoding.ASCII.GetBytes(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注： 若string是使用base64字元輸出，那麼在deserialize時就必須使用<br>Convert.FromBase64String(data) 處理</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ProtoBuf&quot;&gt;&lt;a href=&quot;#ProtoBuf&quot; class=&quot;headerlink&quot; title=&quot;ProtoBuf&quot;&gt;&lt;/a&gt;ProtoBuf&lt;/h1&gt;&lt;p&gt;這一篇應該是我ProtoBuf的系列文章第二篇，上一篇只簡單說了一些安裝方式與一些定義檔&lt;b
      
    
    </summary>
    
      <category term="ProtoBuf" scheme="http://yi-shiuan.github.io/categories/ProtoBuf/"/>
    
    
      <category term="ProtoBuf" scheme="http://yi-shiuan.github.io/tags/ProtoBuf/"/>
    
      <category term="serialize" scheme="http://yi-shiuan.github.io/tags/serialize/"/>
    
      <category term="deserialize" scheme="http://yi-shiuan.github.io/tags/deserialize/"/>
    
  </entry>
  
  <entry>
    <title>[ProtoBuf] 初次見面</title>
    <link href="http://yi-shiuan.github.io/2016/10/05/2016-10-06-protobuf%E5%88%9D%E6%AC%A1%E8%A6%8B%E9%9D%A2/"/>
    <id>http://yi-shiuan.github.io/2016/10/05/2016-10-06-protobuf初次見面/</id>
    <published>2016-10-05T21:30:16.000Z</published>
    <updated>2018-01-03T03:26:48.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ProtoBuf-初次見面"><a href="#ProtoBuf-初次見面" class="headerlink" title="ProtoBuf 初次見面"></a>ProtoBuf 初次見面</h1><h2 id="什麼是ProtoBuf？"><a href="#什麼是ProtoBuf？" class="headerlink" title="什麼是ProtoBuf？"></a>什麼是ProtoBuf？</h2><p>這是一個Google所開發出的資料儲存結構或物件（反）序列的結構（如 JOSN、XML、msgpack等），在官方網站的介紹上有這麼一段：</p><blockquote><p>Protocol buffers are Google’s language-neutral,<br>platform-neutral, extensible mechanism for serializing structured data<br>– think XML, but smaller, faster, and simpler.<br>You define how you want your data to be structured once,<br>then you can use special generated source code to easily write<br>and read your structured data to and from a variety of data streams and using a variety of languages. </p><p style="text-align:right"> from <a href="https://developers.google.com/protocol-buffers/" target="_blank">  https://developers.google.com/protocol-buffers/</a></p></blockquote><p>ProtoBuf支援各種主流的語言(ex: C#, C++, JAVA等)，<br>在官方中的<a href="https://github.com/google/protobuf" target="_blank" rel="noopener">GitHub</a>上有目前支援的語言實做，或是Third-party搜尋相關的實做套件。</p><h3 id="ProtoBuf-優點"><a href="#ProtoBuf-優點" class="headerlink" title="ProtoBuf 優點"></a>ProtoBuf 優點</h3><ul><li>(反)序列<strong>速度快</strong>，方便於網路傳輸</li><li>產出格式<strong>內容小</strong>，方便存放至檔案或其他Service</li></ul><h3 id="ProtoBuf-缺點"><a href="#ProtoBuf-缺點" class="headerlink" title="ProtoBuf 缺點"></a>ProtoBuf 缺點</h3><ul><li>二進位格式，難以閱讀</li><li>使用上必須先作定義，需要先設定.proto檔案</li></ul><h2 id="在-C-中使用-ProtoBuf"><a href="#在-C-中使用-ProtoBuf" class="headerlink" title="在 C# 中使用 ProtoBuf"></a>在 C# 中使用 ProtoBuf</h2><p>在專案中我是使用third-party的套件，<a href="https://www.nuget.org/packages/protobuf-net" target="_blank" rel="noopener">ProtoBuf-net</a><br>套件可以在nuget上找到，會選擇這個套件主要是因為在使用上較為簡便，也支援較多的設定的方式來做資料，設定的方式<br>稍後會有比較詳細一些的介紹。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://iborbw.dm2301.livefilestore.com/y3mwZSHpblZIjBxQ2VXBmnVHV8MUQSMdTVoW4vffVGKs4JCG91fDL-ukzA4rTxhIfuV7fn2vuc2A04qIdxM3phpxfINzJVERuqtJVaGvm7yXCmCQdd0P6qq8Ai9BxYg7deUDWSF4oqEwKg7SiiNF1V5UW52gVN2t-ob2I_IRQ3q73Y?width=1318&height=384&cropmode=none" alt="ProtoBuf-net" title="">                </div>                <div class="image-caption">ProtoBuf-net</div>            </figure><h3 id="定義方式"><a href="#定義方式" class="headerlink" title="定義方式"></a>定義方式</h3><p>ProtoBuf-net設定的方式支援了以下三種方式</p><h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h4><p>這個方式，個人認為是一個較好的設定方式，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ProtoContract</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ProtoMember(1)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> TestA &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">ProtoMember(2)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> TestB &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">ProtoMember(3)</span>]</span><br><span class="line">    <span class="keyword">public</span> TestClassB TestC &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ProtoContract</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClassB</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這一個設定方式可以修改data model同時修改 Attribute 這樣在團隊使用上可以避免修改data model後<br>也可馬上維護protobuf的設定，避免在runtime時因為設定上造成exception。</p><h4 id="proto檔案"><a href="#proto檔案" class="headerlink" title=".proto檔案"></a>.proto檔案</h4><p>這一個方式是官方的標準設定，這個需要額外產生一份.proto檔案，定義方式與格式可參考<br><a href="https://developers.google.com/protocol-buffers/docs/csharptutorial" target="_blank" rel="noopener">官方網站</a><br>的設定。</p><p>這一個方式因為多產生了一個.proto的檔案，在修改data model後，必須要再額外修改.proto的檔案，<br>有時候在開發上會有不一致的情況；在使用上與設定上也相對較為複雜。</p><h4 id="Runtime-定義"><a href="#Runtime-定義" class="headerlink" title="Runtime 定義"></a>Runtime 定義</h4><p>這是在Application執行期間產生一份 RuntimeTypeModel，在Serializer的時候會以這一份RuntimeTypeModel為你的<br>data model做序列化，以下提供語法參考設定方式</p><p>這一個方式會將原先定義覆蓋</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> metaType = RuntimeTypeModel.Default.Add(<span class="keyword">typeof</span>(TestClassA), <span class="literal">true</span>);</span><br><span class="line">metaType.AddSubType(<span class="number">100</span>, <span class="keyword">typeof</span>(TestA));</span><br><span class="line"></span><br><span class="line">RuntimeTypeModel.Default.Add(<span class="keyword">typeof</span>(TestA), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>這一個會複寫(或新增)原先的定義<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> metaType = RuntimeTypeModel.Default;</span><br><span class="line"><span class="keyword">var</span> testA = metaType[<span class="keyword">typeof</span>(TestClassA)];</span><br><span class="line">testA.AddSubType(<span class="number">100</span>, <span class="keyword">typeof</span>(TestA));</span><br><span class="line">metaType.Add(<span class="keyword">typeof</span>(TestA), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>目前會採用ProtoBuf序列化是因為先前使用JSON有效能上的問題與在存取Redis上產生較高的延遲，所以改採用<br>ProtoBuf來作為資料序列化與存放到Redis的主要格式。雖然在閱讀上需要自己寫小工具做轉譯，但在一般情況<br>擁有較好的效能展現。</p><p>其他更詳細的介紹可觀看<br><a href="https://github.com/mgravell/protobuf-net#advanced-subjects" target="_blank" rel="noopener">protobuf-net 官方GitHub</a></p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="http://larrynung.github.io/2016/08/23/protobuf-net-Serialize-DeSerialize-data/" target="_blank" rel="noopener">Level up - protobuf-net - Serialize/DeSerialize data</a></p><p><a href="https://github.com/mgravell/protobuf-net" target="_blank" rel="noopener">protobuf-net 官方GitHub</a></p><p><a href="https://github.com/google/protobuf" target="_blank" rel="noopener">Google protobuf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ProtoBuf-初次見面&quot;&gt;&lt;a href=&quot;#ProtoBuf-初次見面&quot; class=&quot;headerlink&quot; title=&quot;ProtoBuf 初次見面&quot;&gt;&lt;/a&gt;ProtoBuf 初次見面&lt;/h1&gt;&lt;h2 id=&quot;什麼是ProtoBuf？&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="ProtoBuf" scheme="http://yi-shiuan.github.io/categories/ProtoBuf/"/>
    
    
      <category term="ProtoBuf" scheme="http://yi-shiuan.github.io/tags/ProtoBuf/"/>
    
      <category term="serialize" scheme="http://yi-shiuan.github.io/tags/serialize/"/>
    
      <category term="deserialize" scheme="http://yi-shiuan.github.io/tags/deserialize/"/>
    
  </entry>
  
  <entry>
    <title>型態轉換的性能(long.parse vs ToString)</title>
    <link href="http://yi-shiuan.github.io/2016/08/04/2016-08-04-%E5%9E%8B%E6%85%8B%E8%BD%89%E6%8F%9B%E7%9A%84%E6%80%A7%E8%83%BD(long.parse%20vs%20ToString)/"/>
    <id>http://yi-shiuan.github.io/2016/08/04/2016-08-04-型態轉換的性能(long.parse vs ToString)/</id>
    <published>2016-08-04T07:31:09.000Z</published>
    <updated>2018-01-03T03:26:48.914Z</updated>
    
    <content type="html"><![CDATA[<h3 id="型態轉換的性能-long-parse-vs-ToString"><a href="#型態轉換的性能-long-parse-vs-ToString" class="headerlink" title="型態轉換的性能(long.parse vs ToString)"></a>型態轉換的性能(long.parse vs ToString)</h3><h3 id="寫在前面"><a href="#寫在前面" class="headerlink" title="寫在前面"></a>寫在前面</h3><p>在工作上或是在系統開發上，時常會遇到轉型的問題，在小型系統上轉型對系統的負荷微乎其微，但是在巨大交易量的系統上面，就顯的重要了！在許多的1毫秒的累積會讓系統減少許多的交易，正好最近再處理系統的效能調教的問題，面臨到了這個問題順手筆記起來，以免再重新測試一次！<br>另外，本篇文章針對long轉型ToString跟string轉型為long的比較，但相近的int, byte, decimal等等一樣可以適用喔！</p><h3 id="比較一：將long個位數的值轉換成為string"><a href="#比較一：將long個位數的值轉換成為string" class="headerlink" title="比較一：將long個位數的值轉換成為string"></a>比較一：將long個位數的值轉換成為string</h3><p>測試的方式是宣告一個long型態的變數，執行100000次ToString的method所花費的時間約 8 ms ~ 12 ms ！</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longType = <span class="number">1</span>L;</span><br><span class="line"><span class="keyword">var</span> sw = Stopwatch.StartNew();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">100000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">longType.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(sw.Elapsed);</span><br><span class="line">Console.WriteLine(sw.ElapsedMilliseconds);</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/LongVsToString/LongVsToString_1ToString.png" alt="將long個位數的值轉換成為string" title="">                </div>                <div class="image-caption">將long個位數的值轉換成為string</div>            </figure><h3 id="比較二：將string轉換成為long"><a href="#比較二：將string轉換成為long" class="headerlink" title="比較二：將string轉換成為long"></a>比較二：將string轉換成為long</h3><p>這一次是宣告一個一字元的字串轉換成為long，並且執行100000次的long.Parse所需要的時間約 9 ms ~ 17 ms！<br>在這兩次的比較差距並不多，但在實際使用的情況很少會用long存放1的資料，所以我們在測試使用1000000的數值，來做測試<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">var</span> sw = Stopwatch.StartNew();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">100000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span>.Parse(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(sw.Elapsed);</span><br><span class="line">Console.WriteLine(sw.ElapsedMilliseconds);</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/LongVsToString/LongVsToString_1ToLong.png" alt="將string轉換成為long" title="">                </div>                <div class="image-caption">將string轉換成為long</div>            </figure><h3 id="比較三：將1M轉換為字串"><a href="#比較三：將1M轉換為字串" class="headerlink" title="比較三：將1M轉換為字串"></a>比較三：將1M轉換為字串</h3><p>這次使用一百萬的數值轉換成字串，所花費的時間為12 ms ~19 ms！</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varb = <span class="number">1000000</span>L;</span><br><span class="line"><span class="keyword">var</span> sw = Stopwatch.StartNew();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    varb.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(sw.Elapsed);</span><br><span class="line">Console.WriteLine(sw.ElapsedMilliseconds);</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/LongVsToString/LongVsToString_1MTolong.png" alt="將1M轉換為字串" title="">                </div>                <div class="image-caption">將1M轉換為字串</div>            </figure><h3 id="比較四：將”1000000”轉換成為long"><a href="#比較四：將”1000000”轉換成為long" class="headerlink" title="比較四：將”1000000”轉換成為long"></a>比較四：將”1000000”轉換成為long</h3><p>這次使用一百萬的數值轉換成字串，所花費的時間為13 ms ~21 ms！</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varb = <span class="string">"1000000"</span>;</span><br><span class="line"><span class="keyword">var</span> sw = Stopwatch.StartNew();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span>.Parse(varb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(sw.Elapsed);</span><br><span class="line">Console.WriteLine(sw.ElapsedMilliseconds);</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/LongVsToString/LongVsToString_1MTolong.png" alt="將1M轉換為字串" title="">                </div>                <div class="image-caption">將1M轉換為字串</div>            </figure><hr><p>在時間上沒有相差很多，但long轉換成為string的效能仍然比較好！千萬不要小看這微小的差距，魔鬼永遠藏在細節中！另外轉換成long在所花費的時間也比較浮動。</p>]]></content>
    
    <summary type="html">
    
      在工作上或是在系統開發上，時常會遇到轉型的問題，在小型系統上轉型對系統的負荷微乎其微，但是在巨大交易量的系統上面，就顯的重要了！在許多的1毫秒的累積會讓系統減少許多的交易，正好最近再處理系統的效能調教的問題，面臨到了這個問題順手筆記起來，以免再重新測試一次！ 另外，本篇文章針對long轉型ToString跟string轉型為long的比較，但相近的int, byte, decimal等等一樣可以適用喔！
    
    </summary>
    
      <category term="performance" scheme="http://yi-shiuan.github.io/categories/performance/"/>
    
    
      <category term="ToString" scheme="http://yi-shiuan.github.io/tags/ToString/"/>
    
      <category term="long" scheme="http://yi-shiuan.github.io/tags/long/"/>
    
      <category term="parse" scheme="http://yi-shiuan.github.io/tags/parse/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】Redis Pub/Sub 製作應用程式間推播通知</title>
    <link href="http://yi-shiuan.github.io/2016/02/23/2016-02-24-%E3%80%90Redis%E3%80%91Redis%20Pub%20Sub%20%E8%A3%BD%E4%BD%9C%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F%E9%96%93%E6%8E%A8%E6%92%AD%E9%80%9A%E7%9F%A5/"/>
    <id>http://yi-shiuan.github.io/2016/02/23/2016-02-24-【Redis】Redis Pub Sub 製作應用程式間推播通知/</id>
    <published>2016-02-23T19:55:09.000Z</published>
    <updated>2018-01-03T03:26:48.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="寫在前面"><a href="#寫在前面" class="headerlink" title="寫在前面"></a>寫在前面</h2><p>在很多時候我們的部屬環境是很複雜的，無法使用單一個應用程式來解決我們的問題…（例如：Windows server與Linux Server、多個網站或多個不同類型執行個體、網站搭配console應用程式）此時當應用程式間需要配合時是一個很重要的議題，很多人會把資料存放到資料庫，應用程式在定期去擷取尚未處理的資料，等相關資料處理完畢後再到資料庫注記哪些記錄是已經處理完畢的，在這樣的軟體設計與環境相對簡單許多，但是在系統繁忙的時間中，這可不是一個樂觀的狀態了..</p><p>現在Redis具有這樣的功能，可以協助我們設計應用程式間可以互相配合的一個機制，如此一來我們就不需要在透過定期存取資料庫，相關的訊息或相關的資料可以及時的處理！</p><h2 id="Redis-Command"><a href="#Redis-Command" class="headerlink" title="Redis Command"></a>Redis Command</h2><p>在使用推播前需要先瞭解三個指令，這三個指令是做應用程式推播時相關的指令</p><h3 id="Publish"><a href="#Publish" class="headerlink" title="Publish"></a>Publish</h3><h4 id="官網的說明"><a href="#官網的說明" class="headerlink" title="官網的說明"></a>官網的說明</h4><blockquote><p>Available since 2.0.0.</p><p><strong>Time complexity</strong>: O(N+M) where N is the number of clients subscribed to the receiving channel and M is the total number of subscribed patterns (by any client).</p><p>Posts a message to the given channel.</p></blockquote><p>Redis最低版本：2.0<br>這個指令主要的用途就是將訊息推進某一個頻道中。<br>而時間複雜度是：O(N+M)，N是訂閱這個頻道的Client數量，M是所有訂閱者的數量。</p><h4 id="Publish-指令的格式"><a href="#Publish-指令的格式" class="headerlink" title="Publish 指令的格式"></a>Publish 指令的格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Publish [channel] [message]</span><br></pre></td></tr></table></figure><h3 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h3><h4 id="官網的說明-1"><a href="#官網的說明-1" class="headerlink" title="官網的說明"></a>官網的說明</h4><blockquote><p>Available since 2.0.0.</p><p><strong>Time complexity</strong>: O(N) where N is the number of channels to subscribe to.</p><p>Subscribes the client to the specified channels.</p></blockquote><p>Redis最低版本：2.0<br>這個指令主要的用途是訂閱頻道，用來接收訂閱頻道中的訊息。<br>而時間複雜度是：O(N)，N是指要訂閱頻道的總數目</p><h4 id="Subscribe指令格式"><a href="#Subscribe指令格式" class="headerlink" title="Subscribe指令格式"></a>Subscribe指令格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE [channel 1] [channel 2] ...</span><br></pre></td></tr></table></figure><h3 id="UnSubscribe"><a href="#UnSubscribe" class="headerlink" title="UnSubscribe"></a>UnSubscribe</h3><h4 id="官網的說明-2"><a href="#官網的說明-2" class="headerlink" title="官網的說明"></a>官網的說明</h4><blockquote><p>Available since 2.0.0.</p><p><strong>Time complexity</strong>: O(N) where N is the number of clients already subscribed to a channel.</p><p>Unsubscribes the client from the given channels, or from all of them if none is given.</p></blockquote><p>Redis最低版本：2.0<br>這個指令主要的用途是取消訂閱頻道。<br>而時間複雜度是：O(N)，N是指要取消訂閱頻道的總數目</p><h4 id="UnSubscribe指令格式"><a href="#UnSubscribe指令格式" class="headerlink" title="UnSubscribe指令格式"></a>UnSubscribe指令格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNSUBSCRIBE [channel 1] [channel 2] ...</span><br></pre></td></tr></table></figure><h2 id="系統開發"><a href="#系統開發" class="headerlink" title="系統開發"></a>系統開發</h2><h3 id="存取Redis-in-C-：StackExchange-Redis"><a href="#存取Redis-in-C-：StackExchange-Redis" class="headerlink" title="存取Redis in C#：StackExchange.Redis"></a>存取Redis in C#：StackExchange.Redis</h3><p>這是一套存取Redis的一個套件，在稍候的程式開發中，都會使用到這個套件來存取Redis！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package StackExchange.Redis</span><br></pre></td></tr></table></figure><h3 id="Subscribe開發"><a href="#Subscribe開發" class="headerlink" title="Subscribe開發"></a>Subscribe開發</h3><h4 id="Step1-連結Redis"><a href="#Step1-連結Redis" class="headerlink" title="Step1. 連結Redis"></a>Step1. 連結Redis</h4><p>在使用Redis需要先建立connection，才能連結到Redis。再使用StackExchange.Redis 套件時需要先引入他的namespace。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using StackExchange.Redis;</span><br></pre></td></tr></table></figure><p>設定Redis連線可以參考<a href="https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Configuration.md#configuration-options" target="_blank" rel="noopener">這篇文章</a>上面會有參數的說明，這邊沒有一一列舉相關的參數設定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var configurationOptions = new ConfigurationOptions</span><br><span class="line">&#123;</span><br><span class="line">    AbortOnConnectFail = false,</span><br><span class="line">    Password = &quot;password&quot;,</span><br><span class="line">    Ssl = false,</span><br><span class="line">    ConnectTimeout = 6000,</span><br><span class="line">    SyncTimeout = 6000</span><br><span class="line">&#125;;</span><br><span class="line">configurationOptions.EndPoints.Add(new DnsEndPoint(&quot;redis host&quot;, port));</span><br><span class="line">// IP:</span><br><span class="line">// configurationOptions.EndPoints.Add(IP Address, port));</span><br><span class="line">ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(configurationOptions);</span><br></pre></td></tr></table></figure><h4 id="Step2-訂閱頻道"><a href="#Step2-訂閱頻道" class="headerlink" title="Step2. 訂閱頻道"></a>Step2. 訂閱頻道</h4><p>在StackExchange.Redis 取得連線後，開始開發訂閱頻道前要先取得Redis的Subcriber，才能發佈或是訂閱訊息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sub = redis.GetSubscriber();</span><br></pre></td></tr></table></figure><p>在訂閱訊息前，先看一下StackExchange.Redis中Subscribe的說明<br>第一個參數是頻道名稱，這邊可以直接使用字串來代表RedisChannel的型別，第二個是一個Action的委派型別，第三個是commandFlag，這個主要的用途是在描述指令該如何執行，這個參數可以省略。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RedisPubSub/RedisPubSub01.png" alt="Subscribe的說明" title="">                </div>                <div class="image-caption">Subscribe的說明</div>            </figure><p>這裡做一個範例，我在這裡訂閱了一個Study4TW的頻道，然後指定了收到這個訊息要做哪些事情（寫在Do Something中）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sub.Subscribe(&quot;Study4TW&quot;, (channel, message) =&gt;</span><br><span class="line"> &#123;</span><br><span class="line">     // Do Something</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>如此只要寫在系統loading時就可以訂閱到該頻道，這個只要做一次就可以了，不需要每次執行！</p><h4 id="Step3-送出訊息！"><a href="#Step3-送出訊息！" class="headerlink" title="Step3. 送出訊息！"></a>Step3. 送出訊息！</h4><p>送出訊息的指令相當簡單，只要填上你是哪一個頻道，以及你要送出的訊息即可！在RedisChannel與RedisValue兩個型別都可以使用字串來傳遞即可。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/RedisPubSub/RedisPubSub02.png" alt="Publish的說明" title="">                </div>                <div class="image-caption">Publish的說明</div>            </figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub = redis.GetSubscriber();</span><br><span class="line">sub.Publish(<span class="string">"Study4TW"</span>, message);</span><br></pre></td></tr></table></figure><p>在搭配前面Step2的程式碼，在這樣簡單的範例就可以在應用程序間互相通訊了！就不再需要透過資料庫來做訊息通知了，也不用使用IF去判別這一個訊息要怎麼處理或是交給哪一個method處理，增加程式碼的可讀性！是否受用無窮阿？</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="http://redis.io/topics/pubsub" target="_blank" rel="noopener">Redis Pub/Sub</a></p><p><a href="http://redis.io/commands/publish" target="_blank" rel="noopener">Publish - Redis</a></p><p><a href="http://redis.io/commands/subscribe" target="_blank" rel="noopener">Subscribe - Redis</a></p><p><a href="http://redis.io/commands/unsubscribe" target="_blank" rel="noopener">UnSubscribe - Redis</a></p><p><a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="noopener">StackExchange.Redis GitHub</a></p><p><a href="https://www.nuget.org/packages/StackExchange.Redis/" target="_blank" rel="noopener">StackExchange.Redis nuget</a></p>]]></content>
    
    <summary type="html">
    
      在很多時候我們的部屬環境是很複雜的，無法使用單一個應用程式來解決我們的問題...（例如：Windows server與Linux Server、多個網站或多個不同類型執行個體、網站搭配console應用程式）此時當應用程式間需要配合時是一個很重要的議題，很多人會把資料存放到資料庫，應用程式在定期去擷取尚未處理的資料，等相關資料處理完畢後再到資料庫注記哪些記錄是已經處理完畢的，在這樣的軟體設計與環境相對簡單許多，但是在系統繁忙的時間中，這可不是一個樂觀的狀態了..
現在Redis具有這樣的功能，可以協助我們設計應用程式間可以互相配合的一個機制，如此一來我們就不需要在透過定期存取資料庫，相關的訊息或相關的資料可以及時的處理！
    
    </summary>
    
      <category term="Redis" scheme="http://yi-shiuan.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yi-shiuan.github.io/tags/Redis/"/>
    
      <category term="pub" scheme="http://yi-shiuan.github.io/tags/pub/"/>
    
      <category term="sub" scheme="http://yi-shiuan.github.io/tags/sub/"/>
    
      <category term="notify" scheme="http://yi-shiuan.github.io/tags/notify/"/>
    
  </entry>
  
</feed>
