<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.24.47"/><title data-react-helmet="true"></title><link as="script" rel="preload" href="/webpack-runtime-fbdef07c9bc84902069e.js"/><link as="script" rel="preload" href="/framework-88141e8bb2fa5a1effff.js"/><link as="script" rel="preload" href="/app-0c7223f4f50ad1e9e45e.js"/><link as="script" rel="preload" href="/component---src-posts-redis-pub-sub-application-notification-redis-pub-sub-application-notification-mdx-44406131100dacb33631.js"/><link as="fetch" rel="preload" href="/page-data/redis-pub-sub-application-notification/redis-pub-sub-application-notification/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><h1>【Redis】Redis Pub/Sub 製作應用程式間推播通知</h1><h2>寫在前面</h2><p>在很多時候我們的部屬環境是很複雜的，無法使用單一個應用程式來解決我們的問題...（例如：Windows server與Linux Server、多個網站或多個不同類型執行個體、網站搭配console應用程式）此時當應用程式間需要配合時是一個很重要的議題，很多人會把資料存放到資料庫，應用程式在定期去擷取尚未處理的資料，等相關資料處理完畢後再到資料庫注記哪些記錄是已經處理完畢的，在這樣的軟體設計與環境相對簡單許多，但是在系統繁忙的時間中，這可不是一個樂觀的狀態了..</p><p>現在Redis具有這樣的功能，可以協助我們設計應用程式間可以互相配合的一個機制，如此一來我們就不需要在透過定期存取資料庫，相關的訊息或相關的資料可以及時的處理！</p><h2>Redis Command</h2><p>在使用推播前需要先瞭解三個指令，這三個指令是做應用程式推播時相關的指令</p><h3>Publish</h3><h4>官網的說明</h4><blockquote><p>Available since 2.0.0.</p><p><strong>Time complexity</strong>: O(N+M) where N is the number of clients subscribed to the receiving channel and M is the total number of subscribed patterns (by any client).</p><p>Posts a message to the given channel.</p></blockquote><p>Redis最低版本：2.0
這個指令主要的用途就是將訊息推進某一個頻道中。
而時間複雜度是：O(N+M)，N是訂閱這個頻道的Client數量，M是所有訂閱者的數量。</p><h4>Publish 指令的格式</h4><pre><code class="language-shell">Publish [channel] [message]
</code></pre><h3>Subscribe</h3><h4>官網的說明</h4><blockquote><p>Available since 2.0.0.</p><p><strong>Time complexity</strong>: O(N) where N is the number of channels to subscribe to.</p><p>Subscribes the client to the specified channels.</p></blockquote><p>Redis最低版本：2.0
這個指令主要的用途是訂閱頻道，用來接收訂閱頻道中的訊息。
而時間複雜度是：O(N)，N是指要訂閱頻道的總數目</p><h4>Subscribe指令格式</h4><pre><code class="language-shell">SUBSCRIBE [channel 1] [channel 2] ...
</code></pre><h3>UnSubscribe</h3><h4>官網的說明</h4><blockquote><p>Available since 2.0.0.</p><p><strong>Time complexity</strong>: O(N) where N is the number of clients already subscribed to a channel.</p><p>Unsubscribes the client from the given channels, or from all of them if none is given.</p></blockquote><p>Redis最低版本：2.0
這個指令主要的用途是取消訂閱頻道。
而時間複雜度是：O(N)，N是指要取消訂閱頻道的總數目</p><h4>UnSubscribe指令格式</h4><pre><code class="language-shell">UNSUBSCRIBE [channel 1] [channel 2] ...
</code></pre><h2>系統開發</h2><h3>存取Redis in C#：StackExchange.Redis</h3><p>這是一套存取Redis的一個套件，在稍候的程式開發中，都會使用到這個套件來存取Redis！</p><pre><code class="language-cs">Install-Package StackExchange.Redis
</code></pre><h3>Subscribe開發</h3><h4>Step1. 連結Redis</h4><p>在使用Redis需要先建立connection，才能連結到Redis。再使用StackExchange.Redis 套件時需要先引入他的namespace。</p><pre><code class="language-cs">using StackExchange.Redis;
</code></pre><p>設定Redis連線可以參考<a href="https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Configuration.md#configuration-options">這篇文章</a>上面會有參數的說明，這邊沒有一一列舉相關的參數設定。</p><pre><code class="language-cs">var configurationOptions = new ConfigurationOptions
{
    AbortOnConnectFail = false,
    Password = &quot;password&quot;,
    Ssl = false,
    ConnectTimeout = 6000,
    SyncTimeout = 6000
};
configurationOptions.EndPoints.Add(new DnsEndPoint(&quot;redis host&quot;, port));
// IP:
// configurationOptions.EndPoints.Add(IP Address, port));
ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(configurationOptions);
</code></pre><h4>Step2. 訂閱頻道</h4><p>在StackExchange.Redis 取得連線後，開始開發訂閱頻道前要先取得Redis的Subcriber，才能發佈或是訂閱訊息</p><pre><code class="language-cs">var sub = redis.GetSubscriber();
</code></pre><p>在訂閱訊息前，先看一下StackExchange.Redis中Subscribe的說明
第一個參數是頻道名稱，這邊可以直接使用字串來代表RedisChannel的型別，第二個是一個Action的委派型別，第三個是commandFlag，這個主要的用途是在描述指令該如何執行，這個參數可以省略。</p><p><img src="/img/RedisPubSub/RedisPubSub01.png" alt="Subscribe的說明"/></p><p>這裡做一個範例，我在這裡訂閱了一個Study4TW的頻道，然後指定了收到這個訊息要做哪些事情（寫在Do Something中）</p><pre><code class="language-cs">sub.Subscribe(&quot;Study4TW&quot;, (channel, message) =&gt;
 {
     // Do Something
 });
</code></pre><p>如此只要寫在系統loading時就可以訂閱到該頻道，這個只要做一次就可以了，不需要每次執行！</p><h4>Step3. 送出訊息！</h4><p>送出訊息的指令相當簡單，只要填上你是哪一個頻道，以及你要送出的訊息即可！在RedisChannel與RedisValue兩個型別都可以使用字串來傳遞即可。</p><p><img src="/img/RedisPubSub/RedisPubSub02.png" alt="Publish的說明"/></p><pre><code class="language-cs">var sub = redis.GetSubscriber();
sub.Publish(&quot;Study4TW&quot;, message);
</code></pre><p>在搭配前面Step2的程式碼，在這樣簡單的範例就可以在應用程序間互相通訊了！就不再需要透過資料庫來做訊息通知了，也不用使用IF去判別這一個訊息要怎麼處理或是交給哪一個method處理，增加程式碼的可讀性！是否受用無窮阿？</p><h2>參考資料</h2><p><a href="http://redis.io/topics/pubsub">Redis Pub/Sub</a></p><p><a href="http://redis.io/commands/publish">Publish - Redis</a></p><p><a href="http://redis.io/commands/subscribe">Subscribe - Redis</a></p><p><a href="http://redis.io/commands/unsubscribe">UnSubscribe - Redis</a></p><p><a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis GitHub</a></p><p><a href="https://www.nuget.org/packages/StackExchange.Redis/">StackExchange.Redis nuget</a></p></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/redis-pub-sub-application-notification/redis-pub-sub-application-notification/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-44d2a0fd2c7273b8efdc.js"],"app":["/app-0c7223f4f50ad1e9e45e.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-2953f7492475c79b5fbd.js"],"component---src-pages-friends-tsx":["/component---src-pages-friends-tsx-4747d5e1c77ca9dca6dd.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-8c30cce20661b19bb649.js"],"component---src-pages-posts-tsx":["/component---src-pages-posts-tsx-f05d9a56bcfa55736e6c.js"],"component---src-pages-tags-tsx":["/component---src-pages-tags-tsx-bc35bfb992cd22e29c73.js"],"component---src-posts-ecs-deploy-preparing-ecs-deploy-preparing-mdx":["/component---src-posts-ecs-deploy-preparing-ecs-deploy-preparing-mdx-3b260f705dcea3ca835f.js"],"component---src-posts-protobuf-first-meet-protobuf-first-meet-mdx":["/component---src-posts-protobuf-first-meet-protobuf-first-meet-mdx-05453c22d7ae745e2c39.js"],"component---src-posts-protobuf-serialize-and-deserialize-protobuf-serialize-and-deserialize-mdx":["/component---src-posts-protobuf-serialize-and-deserialize-protobuf-serialize-and-deserialize-mdx-5af0f1f68a59fd825eb0.js"],"component---src-posts-redis-pub-sub-application-notification-redis-pub-sub-application-notification-mdx":["/component---src-posts-redis-pub-sub-application-notification-redis-pub-sub-application-notification-mdx-44406131100dacb33631.js"]};/*]]>*/</script><script src="/polyfill-44d2a0fd2c7273b8efdc.js" nomodule=""></script><script src="/component---src-posts-redis-pub-sub-application-notification-redis-pub-sub-application-notification-mdx-44406131100dacb33631.js" async=""></script><script src="/app-0c7223f4f50ad1e9e45e.js" async=""></script><script src="/framework-88141e8bb2fa5a1effff.js" async=""></script><script src="/webpack-runtime-fbdef07c9bc84902069e.js" async=""></script></body></html>