{"version":3,"sources":["webpack:///./src/posts/protobuf-serialize-and-deserialize/protobuf-serialize-and-deserialize.mdx","webpack:///./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"],"names":["_frontmatter","layoutProps","MDXContent","components","props","mdxType","isMDXComponent","_objectWithoutPropertiesLoose","source","excluded","key","i","target","sourceKeys","Object","keys","length","indexOf"],"mappings":"gOAKaA,EAAe,CAC1B,MAAS,+CACT,YAAe,4GACf,KAAQ,CAAC,WAAY,YAAa,eAClC,WAAc,CAAC,YACf,WAAa,EACb,SAAW,EACX,KAAQ,4BAQJC,EAAc,CAClBD,gBAGa,SAASE,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,cALS,UAKT,iBAAeH,EAAiBG,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAC5E,oCACA,sIAGA,wCACA,0IAGA,+CACA,yBAAK,qBAAU,CACX,UAAa,cACb,WAAc,OAFb,0PAgBL,0GAEA,8EACA,yBAAK,qBAAU,CACX,UAAa,cACb,WAAc,OAFb,ofA2BL,yEACA,gCAEE,kBAAO,CACL,WAAc,cADhB,2DAKF,yCACA,0DACA,gDACA,yBAAK,qBAAU,CACX,UAAa,cACb,WAAc,OAFb,6GAQL,gFACA,yBAAK,qBAAU,CACX,UAAa,cACb,WAAc,OAFb,mYAoBL,gCAEE,kBAAO,CACL,WAAc,cADhB,qFASNH,EAAWI,gBAAiB,G,kCCvIb,SAASC,EAA8BC,EAAQC,GAC5D,GAAc,MAAVD,EAAgB,MAAO,GAC3B,IAEIE,EAAKC,EAFLC,EAAS,GACTC,EAAaC,OAAOC,KAAKP,GAG7B,IAAKG,EAAI,EAAGA,EAAIE,EAAWG,OAAQL,IACjCD,EAAMG,EAAWF,GACbF,EAASQ,QAAQP,IAAQ,IAC7BE,EAAOF,GAAOF,EAAOE,IAGvB,OAAOE,EAZT","file":"component---src-posts-protobuf-serialize-and-deserialize-protobuf-serialize-and-deserialize-mdx-e1652248a6935dfbcc31.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"[ProtoBuf] ProtoBuf Serialize 與 DeSerialize！\",\n  \"description\": \"這一篇應該是我ProtoBuf的系列文章第二篇，上一篇只簡單說了一些安裝方式與一些定義檔 的設定根本就不知道該如何使用這一個好用的序列化工具。依樣會是使用protobuf-net 這一個套件來做一個簡單的紀錄。\",\n  \"tags\": [\"ProtoBuf\", \"serialize\", \"deserialize\"],\n  \"categories\": [\"ProtoBuf\"],\n  \"published\": true,\n  \"comment\": true,\n  \"date\": \"2016-10-07T22:44:15.000Z\"\n};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1>{`ProtoBuf`}</h1>\n    <p>{`這一篇應該是我ProtoBuf的系列文章第二篇，上一篇只簡單說了一些安裝方式與一些定義檔\n的設定根本就不知道該如何使用這一個好用的序列化工具。依樣會是使用protobuf-net\n這一個套件來做一個簡單的紀錄。`}</p>\n    <h2>{`ProtoBuf 序列化`}</h2>\n    <p>{`在使用 ProtoBuf 的第一步就必須了解 Stream 的資料格式，因為在(反)序列化\n的過程中，預設都是使用 Stream 作為媒介。序列化的部份是使用 Serializer.Serialize\n這個方法來處理。`}</p>\n    <h3>{`Simple Code 1 - 序列化`}</h3>\n    <pre><code {...{\n        \"className\": \"language-cs\",\n        \"parentName\": \"pre\"\n      }}>{`public void SerializeToStream<T>(T data, Stream stream)\n{\n    Serializer.Serialize(stream, data)\n}\n\npublic void Main()\n{\n    using (var stream = new MemoryStream())\n    {\n        this.SerializeToStream<object>(data, stream);\n    }\n}\n`}</code></pre>\n    <p>{`主要原因是若Stream關閉後就無法做任何的操作，所以交由外部來控制Stream的資源初始與回收。\n可以在序列化成為 Array 或 String 的格式。`}</p>\n    <h3>{`Simple Code 2 - Serialize to byte array and string`}</h3>\n    <pre><code {...{\n        \"className\": \"language-cs\",\n        \"parentName\": \"pre\"\n      }}>{`public byte[] SerializeToBytes<T>(T data)\n{\n    byte[] result;\n    using (var stream = new MemoryStream())\n    {\n        this.SerializeToStream(data, stream);\n        result = stream.ToArray();\n    }\n\n    return result;\n}\n\npublic string SerializeToString<T>(T data)\n{\n    string result;\n    using (var stream = new MemoryStream())\n    {\n        this.SerializeToStream(data, stream);\n        result = Encoding.ASCII.GetString(stream.ToArray());\n    }\n\n    return result;\n}\n`}</code></pre>\n    <p>{`在Format 成 String 我是採用ASCII的編碼方式，讓他出來會像16進位的感覺。`}</p>\n    <blockquote>\n\n      <p {...{\n        \"parentName\": \"blockquote\"\n      }}>{`也可以使用 Convert.ToBase64String(stream.ToArray()); 產生文字資料`}</p>\n\n    </blockquote>\n    <h2>{`ProtoBuf 反序列化`}</h2>\n    <p>{`在反序列化的部分也是預設採用 Stream 的資料格式來處理，`}</p>\n    <h3>{`Simple Code 3 - 反序列化`}</h3>\n    <pre><code {...{\n        \"className\": \"language-cs\",\n        \"parentName\": \"pre\"\n      }}>{`public T SerializeToStream<T>(Stream stream)\n{\n    return Serializer.Deserialize<T>(stream, data)\n}\n`}</code></pre>\n    <h3>{`Simple Code 4 - 針對 Byte array and string deserialize`}</h3>\n    <pre><code {...{\n        \"className\": \"language-cs\",\n        \"parentName\": \"pre\"\n      }}>{`public T DeSerializeFromBytes<T>(byte[] data)\n{\n    T result;\n    using (var stream = new MemoryStream(data))\n    {\n        stream.Seek(0, SeekOrigin.Begin);\n        result = this.DeSerializeFromStream<T>(stream);\n    }\n\n    return result;\n}\n\npublic T DeSerializeFromString<T>(string data)\n{\n    return this.DeSerializeFromBytes<T>(Encoding.ASCII.GetBytes(data));\n}\n`}</code></pre>\n    <blockquote>\n\n      <p {...{\n        \"parentName\": \"blockquote\"\n      }}>{`注： 若string是使用base64字元輸出，那麼在deserialize時就必須使用\nConvert.FromBase64String(data) 處理`}</p>\n\n    </blockquote>\n  </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}"],"sourceRoot":""}