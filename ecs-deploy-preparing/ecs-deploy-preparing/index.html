<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.24.53"/><title data-react-helmet="true"></title><link as="script" rel="preload" href="/webpack-runtime-f2e003e6be60fc7aa098.js"/><link as="script" rel="preload" href="/framework-fca5a6c89ebf46562859.js"/><link as="script" rel="preload" href="/app-c37cb832fa2bf360a726.js"/><link as="script" rel="preload" href="/component---src-posts-ecs-deploy-preparing-ecs-deploy-preparing-mdx-83261c4537c9295dd744.js"/><link as="fetch" rel="preload" href="/page-data/ecs-deploy-preparing/ecs-deploy-preparing/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><h1>AWS ECS Preparing Release 紀錄</h1><h2>寫在前面</h2><p>我們在aws 做Production deploy的時候，都會有一個pre production的環境，這個環境主要是為了在部署流程結束後可以做概念性驗證的環境
（主要測試：db connection是否正常、網路連線、裝機腳本等等）另一個方面可以預熱application，不過我們開始有越來越多採用docker的
application並且使用ECS的部署模式，但是ECS的Service建立後就無法修改Target Group，因此沒辦法如同EC2的部署模式只在最後切換Target Group</p><h2>構思&amp;實作</h2><p>一開始其實想得很簡單，就是每次部署時都要產生新的 Target group 與新的ECS Service，
將新產生的Target Group掛載到ELB的preparing規則上，然後驗證完畢後就把這組Target Group掛載到ELB的 public規則上就完成了一次的部署</p><p>但...事件總是沒想像中的美好，原先預計兩週內可以完成的項目變到了三週(其實中間也有對自己的要求增加ex: script可以重跑、自動移除舊版本等等)</p><h3>Deploy Configuration</h3><p>這個是為了減少使用者輸入資訊所做的一個設定，內容主要如下</p><pre><code class="language-yaml">VPC:
Region:
HealthCheck:
    Path: &quot;/&quot;
    UnhealthyThreshold: 2
    HealthyThreshold: 5
LoadBalancer:
    Preparing:
    Public:
AutoScaling:
    Desired: 2
    MaxCount: 10
    MinCount: 2
Policies:
    - Name: Scale-By-CPU-Usage
      CoolDown: 150
      Threshold: 75.0
      Metric: ECSServiceAverageCPUUtilization
    - Name: Scale-By-Memory-Usage
      CoolDown: 150
      Threshold: 75.0
      Metric: ECSServiceAverageMemoryUtilization
</code></pre><h3>Step1. 建立Target Group</h3><p>在建立Target Group其實沒什麼坑主要踩到的就是Target group的名字不能超過<strong>32</strong>個字所以在命名規劃上需要思考一下該如何呈現</p><blockquote><p>我的命名規則是：環境-服務名稱-版本號</p></blockquote><p>這一步執行的結果需要將內容記錄下來，在修改ELB的rule時會需要用到</p><pre><code class="language-yaml">- name: Create Target Group
  elb_target_group:
    vpc_id: &quot;{{ VPC }}&quot;
    region: &quot;{{ Region }}&quot;
    state: present
    name: &quot;{{ name }}&quot;
    protocol: http
    port: 80
    health_check_protocol: http
    health_check_interval: 30
    health_check_timeout: 5
    health_check_path: &quot;{{ HealthCheck.Path }}&quot;
    unhealthy_threshold_count: &quot;{{ HealthCheck.UnhealthyThreshold }}&quot;
    healthy_threshold_count: &quot;{{ HealthCheck.HealthyThreshold }}&quot;
    successful_response_codes: &quot;200&quot;
    target_type: instance
    deregistration_delay_timeout: 60
    tags:
      Cluster: &quot;{{ cluster }}&quot;
      ENV: &quot;{{ env }}&quot;
      Version: &quot;{{ version }}&quot;
      Name: &quot;{{ name }}&quot;
      CreateTime: &quot;{{ lookup(&#x27;pipe&#x27;,&#x27;date +%Y%m%d&#x27;) }}&quot;
  register: target_group_result
</code></pre><h3>Step2. 連結ELB 的規則</h3><p>這一步在ansible中這定較為複雜所以改用了aws cli來處理，如果你想用純的ansible的方式處理，可以參考
<a href="https://docs.ansible.com/ansible/latest/modules/elb_application_lb_module.html#elb-application-lb-module">這篇(elb_application_lb)</a></p><p>ansible的回傳都是陣列的形式所以在存取result的時候需要取得第一筆資料（如果你建立了多個target group
就可以用loop來處理）</p><pre><code class="language-yaml">- name: Attach new target group to preparing load balancer rule
  shell: |
    aws elbv2 modify-rule \
      --actions Type=forward,TargetGroupArn={{ target_group_result.results[0].target_group_arn }} \
      --rule-arn {{ LoadBalancer.Preparing }} \
      --region {{ Region }}
</code></pre><h3>Step3. 註冊新的Task Definition</h3><p>這一步驟來說應該是最複雜的一部分，我的Task Definition是由專案中的一個Configuration檔案設定
在CI建置完成後上傳到artifact server，在執行部屬時用ansible下載到Deploy server上在讀取到
ansible的變數中。</p><p>在專案中的Configuration不是一整份的設定值，他只記錄了一部分的資訊(ex: cpu, memory, family等)
主要的原因是有些資料需要在deploy時才能決定(ex: image version, env...)，
所以我會在註冊task definition前先透過configuration建立一份完整的task definition，
再透過aws cli來註冊新的task definition</p><p>這邊你會有個疑問，為何不直接採用
<a href="https://docs.ansible.com/ansible/latest/modules/ecs_taskdefinition_module.html#ecs-taskdefinition-module">ansible module</a>
呢?主要原因是之前我們就有ecs deploy的CD流程，當時候有些參數我們需要但ansible無法支援
所以轉用aws cli的方式進行。</p><pre><code class="language-yaml">- name: &quot;Register Task Definition&quot;
  shell: |
    aws ecs register-task-definition \
      --cli-input-json &#x27;{{ td_setting | to_json }}&#x27; \
      --region {{ Region }};
</code></pre><h3>Step4. 新建ECS Service</h3><p>這一步我依舊採用aws cli來建立service，主要的原因是我的service通常會由兩個target group
指向兩個不同的ELB與domain，在ansible官方網站上並沒有太多的說明與所需要的參數，因此我轉用了
aws cli，如同step3我會先將所需要的設定在一個ansible task上做好 產生了<code>service_setting</code>的參數
在執行cli時將參數轉換成JSON代入</p><pre><code class="language-yaml">- name: &quot;Create ECS service {{ service_setting.serviceName }}&quot;
  shell: |
    aws ecs create-service \
      --service-name &#x27;{{ service_setting.serviceName }}&#x27; \
      --cli-input-json &#x27;{{ service_setting | to_json }}&#x27; \
      --region {{ Region }};
  register: ecs_service_create
</code></pre><h2>切換Service Version</h2><p>切換服務版本這是一個比較大的工程，剛才的部署的複雜度更高一些，主要概念就是將新產生的target group
掛載到真正線上服務的ELB上，不過呢這件事情衍生了許多細細小小的項目要處理的細節也比較多</p><h3>Step1. 確認Target group health count</h3><p>要切換前一定要先檢查Target group的target狀態，如果沒確認切換了一個還在做health check的target
group就會發生線上可能當下沒有機器服務的窘境，所以第一步肯定就是確認health count</p><pre><code class="language-yaml">- name: Get Target Group Informantion
  elb_target_group_info:
    region: &quot;{{ Region }}&quot;
    collect_targets_health: yes
    names: &quot;{{ switch_target_group }}&quot;
  register: target_group_result
  failed_when: (target_group_result | json_query(&#x27;target_groups[].targets_health_description[].target_health.state&#x27;) | length) &lt; {{ AutoScaling.Desired }}
</code></pre><p>當如果target的health count沒有達到要求數量我就讓playbook失敗，之前在ec2的做法是要完全healthy
才能夠往下運行但這樣會遇到當下要switch會無法switch，所以這次改變一下做法讓target的health count
只要大於要求數量即可</p><h3>Step2. 取得public當前的target group</h3><p>為什麼要取得當前的target group？主要原因是怕瞬斷的情況發生，所以在切換的時候會有一個時間區間同時
有兩個版本在運行最後再將舊版本移除</p><p>取得ELB中的rule資料ansible並沒有太好的方式處理，所以這道題還是只能靠aws cli來協助了，aws cli 只需要輸入public rule的arn就可以取得了
詳細可以看<a href="https://awscli.amazonaws.com/v2/documentation/api/latest/reference/elbv2/describe-rules.html">aws cli</a> 的官方文件</p><pre><code class="language-yaml">- name: &quot;Get load balancer rule for {{ service_name | upper }}&quot;
  shell: |
    aws elbv2 describe-rules \
      --rule-arns {{ LoadBalancer.Public | join(&#x27; &#x27;) }} \
      --region {{ Region }}
  register: current_rules
</code></pre><p>接下來這個就需要比較耐心地來處理了，因為ansible shell的回傳result會有個stdout屬性，這就是aws cli最後回傳的資料，所以我們要解析這個
資訊，然後ansible 的json_query是用<a href="https://jmespath.org/">這個</a>來實作的，所以我們可以透過這個先取得我們想要的結果，當然他會有一個target group arn資料
不過我們後面需要一些壓在target group tag上的資料，所以我在這邊把他先取回來</p><pre><code class="language-yaml">- name: Get target group informantion of current load balance setting
  elb_target_group_info:
    region: &quot;{{ Region }}&quot;
    target_group_arns: &quot;{{ current_rules.stdout | from_json | json_query(&#x27;Rules[].Actions[].ForwardConfig.TargetGroups[].TargetGroupArn&#x27;) }}&quot;
  register: current_target_group_result
</code></pre><h3>Step3. 把Prepare的target group跟public的整合在一起</h3><p>在ansible還時沒有一個簡單的設定，去修改ELB rule的target group連結，所以還是得透過aws cli來作了</p><blockquote><p>下面的ansible tasks我將它設定成一個role，主要原因是我有兩個target group在處理，
<code>set_fact</code>去跑loop的情況會比較複雜所以我設計成一個role，在playbook上採用loop
來執行這個role，如此一來邏輯比較清晰也比較好維護</p></blockquote><p>如此一來在public 的規則上就有兩個target group的容器在服務了，這樣的情況我會讓他維持約1分鐘，再將原先的target group移除</p><pre><code class="language-yaml">- name: Generate load balance rule setting
 set_fact:
   target_rule_setting: |
     [
       {
         &quot;Type&quot;: &quot;forward&quot;,
         &quot;ForwardConfig&quot;: {
           &quot;TargetGroups&quot;: [
             {
               &quot;TargetGroupArn&quot;: &#x27;{{ target_group[0].arn }}&#x27;,
               &quot;Weight&quot;: {{ target_group[0].weight }}
             },
             {
               &quot;TargetGroupArn&quot;: &#x27;{{ target_group[1].arn }}&#x27;,
               &quot;Weight&quot;: {{ target_group[1].weight }}
             }
           ],
           &quot;TargetGroupStickinessConfig&quot;: {
             &quot;Enabled&quot;: false
           }
         }
       }
     ]
- name: &quot;Attach to public rule&quot;
 shell: |
   aws elbv2 modify-rule \
     --actions &#x27;{{ target_rule_setting | to_json }}&#x27; \
     --rule-arn {{ target_rule }} \
     --region {{ Region }}

- name: &quot;Remove old version&quot;
 shell: |
   aws elbv2 modify-rule \
     --actions Type=forward,TargetGroupArn={{ item }} \
     --rule-arn {{ LoadBalancer.Release[ansible_loop.index0].Rule }} \
     --region {{ Region }}
</code></pre><h3>Step4. 處置舊版本的服務</h3><p>移轉成功後需要把舊版本的service關機或是移除，我的選擇是暫時關閉</p><p>關閉服務聽起來很簡單，但我用aws cli執行將需求值改成0，但....一點效果都沒有！！</p><p>還記得一開始設定的autoscaling嗎....沒錯就是他！當你把desired改成0，會跟autoscaling設定的發生衝突所以變得無效</p><p>在調整desired改成0前，要把autoscaling設定移除才能順利的關閉service將cluster的資源釋出！</p><pre><code class="language-yaml">- name: Shutdown ECS service
  shell: |
    aws application-autoscaling register-scalable-target \
      --service-namespace ecs \
      --scalable-dimension ecs:service:DesiredCount \
      --resource-id service/{{ current_target_group_result.target_groups[0].tags[&quot;Cluster&quot;] }}/{{ current_target_group_result.target_groups[0].tags[&quot;Name&quot;] }} \
      --min-capacity 0 \
      --max-capacity 0 \
      --region {{ Region }};
    aws ecs update-service \
      --cluster {{ current_target_group_result.target_groups[0].tags[&quot;Cluster&quot;] }} \
      --service {{ current_target_group_result.target_groups[0].tags[&quot;Name&quot;] }} \
      --desired-count 0 \
      --region {{ Region }};
</code></pre><h3>Step5. 移除</h3><p>這是整個部署流程的尾聲了（或是你可以選擇不做....）</p><p>我的做法是先將整個ecs cluster的service列出來，然後取得target group資料，再由target group資料取得tag是否含有<code>obsolete</code>的tag</p><pre><code class="language-yaml">- name: Get obsolete target group info
  elb_target_group_info:
    region: &quot;{{ Region }}&quot;
    target_group_arns: &quot;{{ target_group_arn | json_query(&#x27;loadBalancers[].targetGroupArn&#x27;) }}&quot;
  register: ecs_tg_result

- name: Delete obsolete ECS service and target group
  shell: |
    aws ecs delete-service \
      --cluster {{ ecs_tg_result.target_groups[0].tags[&#x27;Cluster&#x27;] }} \
      --service {{ ecs_tg_result.target_groups[0].tags[&#x27;Service&#x27;] }} \
      --region {{ Region }} ;
    aws elbv2 delete-target-group \
      --target-group-arn {{ ecs_tg_result.target_groups[0].target_group_arn }} \
      --region {{ Region }} ;
    aws elbv2 delete-target-group \
      --target-group-arn {{ ecs_tg_result.target_groups[1].target_group_arn }} \
      --region {{ Region }} ;
  when: ecs_tg_result.target_groups[0].tags[&#x27;Obsolete&#x27;] is defined
</code></pre><h3>Step6. 標記</h3><p>部署的最後一步，標記已經被關閉的服務變成<code>obsolete</code></p><p>這是為了下次部署可以把這些服務刪除，如果前一個步驟不做的話，這個步驟也是可以省略的。</p><pre><code class="language-yaml">- name: Configure obsolete target group
 shell: |
   aws elbv2 add-tags \
     --resource-arns {{ item.target_group_arn }} \
     --tags &#x27;[{&quot;Key&quot;: &quot;Obsolete&quot;, &quot;Value&quot;: &quot;yes&quot;}]&#x27; \
     --region {{ Region }}
 loop: &quot;{{ current_target_group_result.target_groups }}&quot;
</code></pre></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/ecs-deploy-preparing/ecs-deploy-preparing/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-66ec64b36522540f0ea8.js"],"app":["/app-c37cb832fa2bf360a726.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-2c58f41fde4ecaf283b9.js"],"component---src-pages-about-tsx":["/component---src-pages-about-tsx-5aa2d8f90c6c04d80e01.js"],"component---src-pages-friends-tsx":["/component---src-pages-friends-tsx-b24ff950306643fc510e.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-d702cdd1d4f1ec2f817a.js"],"component---src-pages-posts-tsx":["/component---src-pages-posts-tsx-91b117f33b87f9fae926.js"],"component---src-pages-tags-tsx":["/component---src-pages-tags-tsx-cf44fb007d1c0af5d3a9.js"],"component---src-posts-ecs-deploy-preparing-ecs-deploy-preparing-mdx":["/component---src-posts-ecs-deploy-preparing-ecs-deploy-preparing-mdx-83261c4537c9295dd744.js"],"component---src-posts-protobuf-first-meet-protobuf-first-meet-mdx":["/component---src-posts-protobuf-first-meet-protobuf-first-meet-mdx-5e0341cde81eb8187b21.js"],"component---src-posts-protobuf-serialize-and-deserialize-protobuf-serialize-and-deserialize-mdx":["/component---src-posts-protobuf-serialize-and-deserialize-protobuf-serialize-and-deserialize-mdx-7678852e51555d318927.js"],"component---src-posts-redis-data-types-redis-data-types-mdx":["/component---src-posts-redis-data-types-redis-data-types-mdx-bc1911b260a318ab2b47.js"],"component---src-posts-redis-pub-sub-application-notification-redis-pub-sub-application-notification-mdx":["/component---src-posts-redis-pub-sub-application-notification-redis-pub-sub-application-notification-mdx-dc33f1a672c356e598f7.js"]};/*]]>*/</script><script src="/polyfill-66ec64b36522540f0ea8.js" nomodule=""></script><script src="/component---src-posts-ecs-deploy-preparing-ecs-deploy-preparing-mdx-83261c4537c9295dd744.js" async=""></script><script src="/app-c37cb832fa2bf360a726.js" async=""></script><script src="/framework-fca5a6c89ebf46562859.js" async=""></script><script src="/webpack-runtime-f2e003e6be60fc7aa098.js" async=""></script></body></html>